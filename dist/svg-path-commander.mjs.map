{"version":3,"file":"svg-path-commander.mjs","sources":["../src/options/options.ts","../src/parser/error.ts","../src/parser/paramsCount.ts","../src/parser/finalizeSegment.ts","../src/parser/scanFlag.ts","../src/parser/isDigit.ts","../src/parser/invalidPathValue.ts","../src/parser/scanParam.ts","../src/parser/isSpace.ts","../src/parser/skipSpaces.ts","../src/parser/isPathCommand.ts","../src/parser/isDigitStart.ts","../src/parser/isArcCommand.ts","../src/parser/scanSegment.ts","../src/parser/pathParser.ts","../src/util/isPathArray.ts","../src/parser/parsePathString.ts","../src/math/polygonArea.ts","../src/math/distanceSquareRoot.ts","../src/math/polygonLength.ts","../node_modules/@thednp/dommatrix/dist/dommatrix.cjs","../src/util/isAbsoluteArray.ts","../src/convert/pathToAbsolute.ts","../src/process/normalizeSegment.ts","../src/util/isNormalizedArray.ts","../src/parser/paramsParser.ts","../src/process/normalizePath.ts","../src/math/midPoint.ts","../src/util/segmentLineFactory.ts","../src/util/segmentArcFactory.ts","../src/util/segmentCubicFactory.ts","../src/util/segmentQuadFactory.ts","../src/util/pathLengthFactory.ts","../src/util/getPathBBox.ts","../src/process/fixArc.ts","../src/util/isCurveArray.ts","../src/math/rotateVector.ts","../src/process/arcToCubic.ts","../src/process/quadToCubic.ts","../src/process/lineToCubic.ts","../src/process/segmentToCubic.ts","../src/convert/pathToCurve.ts","../src/util/getPathArea.ts","../src/util/getTotalLength.ts","../src/util/getDrawDirection.ts","../src/util/getPointAtLength.ts","../src/util/getPropertiesAtLength.ts","../src/util/getPropertiesAtPoint.ts","../src/util/getClosestPoint.ts","../src/util/getSegmentOfPoint.ts","../src/util/getSegmentAtLength.ts","../src/util/isPointInStroke.ts","../src/util/isValidPath.ts","../src/util/isRelativeArray.ts","../src/process/roundPath.ts","../src/convert/pathToString.ts","../src/util/shapeToPath.ts","../src/process/splitPath.ts","../src/convert/pathToRelative.ts","../src/process/shortenSegment.ts","../src/process/optimizePath.ts","../src/process/reverseCurve.ts","../src/process/reversePath.ts","../src/process/getSVGMatrix.ts","../src/process/projection2d.ts","../src/process/transformPath.ts","../src/process/splitCubic.ts","../src/index.ts"],"sourcesContent":["import { Options } from '../interface';\n\n/** SVGPathCommander default options */\nconst defaultOptions: Options = {\n  origin: [0, 0, 0],\n  round: 4,\n};\n\nexport default defaultOptions;\n","const error = 'SVGPathCommander Error';\nexport default error;\n","/** Segment params length */\nconst paramsCount = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nexport default paramsCount;\n","import paramsCount from './paramsCount';\nimport PathParser from './pathParser';\nimport type { PathCommand, PathSegment, RelativeCommand } from '../types';\n\n/**\n * Breaks the parsing of a pathString once a segment is finalized.\n *\n * @param path the `PathParser` instance\n */\nconst finalizeSegment = (path: PathParser) => {\n  let pathCommand = path.pathValue[path.segmentStart] as PathCommand;\n  let LK = pathCommand.toLowerCase() as RelativeCommand;\n  const { data } = path;\n\n  while (data.length >= paramsCount[LK]) {\n    // overloaded `moveTo`\n    // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts\n    if (LK === 'm' && data.length > 2) {\n      path.segments.push([pathCommand, ...(data.splice(0, 2) as number[])] as PathSegment);\n      LK = 'l';\n      pathCommand = pathCommand === 'm' ? 'l' : 'L';\n    } else {\n      path.segments.push([pathCommand, ...(data.splice(0, paramsCount[LK]) as number[])] as PathSegment);\n    }\n\n    if (!paramsCount[LK]) {\n      break;\n    }\n  }\n};\nexport default finalizeSegment;\n","import error from './error';\nimport type PathParser from './pathParser';\n\n/**\n * Validates an A (arc-to) specific path command value.\n * Usually a `large-arc-flag` or `sweep-flag`.\n *\n * @param path the `PathParser` instance\n */\nconst scanFlag = (path: PathParser) => {\n  const { index, pathValue } = path;\n  const code = pathValue.charCodeAt(index);\n\n  if (code === 0x30 /* 0 */) {\n    path.param = 0;\n    path.index += 1;\n    return;\n  }\n\n  if (code === 0x31 /* 1 */) {\n    path.param = 1;\n    path.index += 1;\n    return;\n  }\n\n  path.err = `${error}: invalid Arc flag \"${pathValue[index]}\", expecting 0 or 1 at index ${index}`;\n};\n\nexport default scanFlag;\n","import { DigitNumber } from '../types';\n\n/**\n * Checks if a character is a digit.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigit = (code: number): code is DigitNumber => {\n  return code >= 48 && code <= 57; // 0..9\n};\nexport default isDigit;\n","const invalidPathValue = 'Invalid path value';\nexport default invalidPathValue;\n","import isDigit from './isDigit';\nimport invalidPathValue from './invalidPathValue';\nimport error from './error';\nimport type PathParser from './pathParser';\n\n/**\n * Validates every character of the path string,\n * every path command, negative numbers or floating point numbers.\n *\n * @param path the `PathParser` instance\n */\nconst scanParam = (path: PathParser) => {\n  const { max, pathValue, index: start } = path;\n  let index = start;\n  let zeroFirst = false;\n  let hasCeiling = false;\n  let hasDecimal = false;\n  let hasDot = false;\n  let ch;\n\n  if (index >= max) {\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"pathValue\" is missing param`;\n    return;\n  }\n  ch = pathValue.charCodeAt(index);\n\n  if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n    index += 1;\n    // ch = (index < max) ? pathValue.charCodeAt(index) : 0;\n    ch = pathValue.charCodeAt(index);\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  if (!isDigit(ch) && ch !== 0x2e /* . */) {\n    // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" is not a number`;\n    return;\n  }\n\n  if (ch !== 0x2e /* . */) {\n    zeroFirst = ch === 0x30 /* 0 */;\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        // path.err = 'SvgPath: numbers started with `0` such as `09`\n        // are illegal (at pos ' + start + ')';\n        path.err = `${error}: ${invalidPathValue} at index ${start}, \"${pathValue[start]}\" illegal number`;\n        return;\n      }\n    }\n\n    while (index < max && isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasCeiling = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x2e /* . */) {\n    hasDot = true;\n    index += 1;\n    while (isDigit(pathValue.charCodeAt(index))) {\n      index += 1;\n      hasDecimal = true;\n    }\n\n    ch = pathValue.charCodeAt(index);\n  }\n\n  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid float exponent`;\n      return;\n    }\n\n    index += 1;\n\n    ch = pathValue.charCodeAt(index);\n\n    if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {\n      index += 1;\n    }\n    if (index < max && isDigit(pathValue.charCodeAt(index))) {\n      while (index < max && isDigit(pathValue.charCodeAt(index))) {\n        index += 1;\n      }\n    } else {\n      path.err = `${error}: ${invalidPathValue} at index ${index}, \"${pathValue[index]}\" invalid integer exponent`;\n      return;\n    }\n  }\n\n  path.index = index;\n  path.param = +path.pathValue.slice(start, index);\n};\nexport default scanParam;\n","import type { SpaceNumber } from '../types';\n\n/**\n * Checks if the character is a space.\n *\n * @param ch the character to check\n * @returns check result\n */\n\nconst isSpace = (ch: number): ch is SpaceNumber => {\n  const allSpaces = [\n    // Special spaces\n    0x1680, 0x180e, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202f,\n    0x205f, 0x3000, 0xfeff,\n    // Line terminators\n    0x0a, 0x0d, 0x2028, 0x2029,\n    // White spaces\n    0x20, 0x09, 0x0b, 0x0c, 0xa0,\n  ];\n\n  return allSpaces.includes(ch);\n};\nexport default isSpace;\n","import isSpace from './isSpace';\nimport type PathParser from './pathParser';\n\n/**\n * Points the parser to the next character in the\n * path string every time it encounters any kind of\n * space character.\n *\n * @param path the `PathParser` instance\n */\nconst skipSpaces = (path: PathParser) => {\n  const { pathValue, max } = path;\n  while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {\n    path.index += 1;\n  }\n};\nexport default skipSpaces;\n","import type { PathCommandNumber } from '../types';\n\n/**\n * Checks if the character is a path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isPathCommand = (code: number): code is PathCommandNumber => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  switch (code | 0x20) {\n    case 0x6d /* m */:\n    case 0x7a /* z */:\n    case 0x6c /* l */:\n    case 0x68 /* h */:\n    case 0x76 /* v */:\n    case 0x63 /* c */:\n    case 0x73 /* s */:\n    case 0x71 /* q */:\n    case 0x74 /* t */:\n    case 0x61 /* a */:\n      // case 0x72/* r */:\n      return true;\n    default:\n      return false;\n  }\n};\nexport default isPathCommand;\n","import isDigit from './isDigit';\nimport type { DigitNumber } from '../types';\n\n/**\n * Checks if the character is or belongs to a number.\n * [0-9]|+|-|.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isDigitStart = (code: number): code is DigitNumber | 0x2b | 0x2d | 0x2e => {\n  return isDigit(code) /* 0..9 */ || code === 0x2b /* + */ || code === 0x2d /* - */ || code === 0x2e; /* . */\n};\nexport default isDigitStart;\n","/**\n * Checks if the character is an A (arc-to) path command.\n *\n * @param code the character to check\n * @returns check result\n */\nconst isArcCommand = (code: number): code is 0x61 => {\n  // eslint-disable-next-line no-bitwise -- Impossible to satisfy\n  return (code | 0x20) === 0x61;\n};\nexport default isArcCommand;\n","import finalizeSegment from './finalizeSegment';\nimport paramCounts from './paramsCount';\nimport scanFlag from './scanFlag';\nimport scanParam from './scanParam';\nimport skipSpaces from './skipSpaces';\nimport isPathCommand from './isPathCommand';\nimport isDigitStart from './isDigitStart';\nimport isArcCommand from './isArcCommand';\nimport invalidPathValue from './invalidPathValue';\nimport error from './error';\n\nimport type PathParser from './pathParser';\nimport { RelativeCommand } from '../types';\n\n/**\n * Scans every character in the path string to determine\n * where a segment starts and where it ends.\n *\n * @param path the `PathParser` instance\n */\nconst scanSegment = (path: PathParser) => {\n  const { max, pathValue, index } = path;\n  const cmdCode = pathValue.charCodeAt(index);\n  const reqParams = paramCounts[pathValue[index].toLowerCase() as RelativeCommand];\n\n  path.segmentStart = index;\n\n  if (!isPathCommand(cmdCode)) {\n    path.err = `${error}: ${invalidPathValue} \"${pathValue[index]}\" is not a path command`;\n    return;\n  }\n\n  path.index += 1;\n  skipSpaces(path);\n\n  path.data = [];\n\n  if (!reqParams) {\n    // Z\n    finalizeSegment(path);\n    return;\n  }\n\n  for (;;) {\n    for (let i = reqParams; i > 0; i -= 1) {\n      if (isArcCommand(cmdCode) && (i === 3 || i === 4)) scanFlag(path);\n      else scanParam(path);\n\n      if (path.err.length) {\n        return;\n      }\n      path.data.push(path.param);\n\n      skipSpaces(path);\n\n      // after ',' param is mandatory\n      if (path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */) {\n        path.index += 1;\n        skipSpaces(path);\n      }\n    }\n\n    if (path.index >= path.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(pathValue.charCodeAt(path.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(path);\n};\nexport default scanSegment;\n","import type { PathArray, PathSegment } from '../types';\n\n/**\n * The `PathParser` is used by the `parsePathString` static method\n * to generate a `pathArray`.\n *\n * @param pathString\n */\nexport default class PathParser {\n  declare segments: PathArray | PathSegment[];\n  declare pathValue: string;\n  declare max: number;\n  declare index: number;\n  declare param: number;\n  declare segmentStart: number;\n  declare data: any[];\n  declare err: string;\n\n  constructor(pathString: string) {\n    this.segments = [];\n    this.pathValue = pathString;\n    this.max = pathString.length;\n    this.index = 0;\n    this.param = 0.0;\n    this.segmentStart = 0;\n    this.data = [];\n    this.err = '';\n  }\n}\n","import type { PathArray, PathSegment, RelativeCommand } from '../types';\nimport paramsCount from '../parser/paramsCount';\n\n/**\n * Iterates an array to check if it's an actual `pathArray`.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isPathArray = (path: unknown): path is PathArray => {\n  return (\n    Array.isArray(path) &&\n    path.every((seg: PathSegment) => {\n      const lk = seg[0].toLowerCase() as RelativeCommand;\n      return paramsCount[lk] === seg.length - 1 && 'achlmqstvz'.includes(lk);\n    })\n  );\n};\nexport default isPathArray;\n","import scanSegment from './scanSegment';\nimport skipSpaces from './skipSpaces';\nimport PathParser from './pathParser';\nimport isPathArray from '../util/isPathArray';\nimport type { PathArray } from '../types';\n\n/**\n * Parses a path string value and returns an array\n * of segments we like to call `pathArray`.\n *\n * @param pathInput the string to be parsed\n * @returns the resulted `pathArray` or error string\n */\nconst parsePathString = (pathInput: string | PathArray): PathArray => {\n  if (isPathArray(pathInput)) {\n    return [...pathInput];\n  }\n\n  const path = new PathParser(pathInput);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  if (path.err && path.err.length) {\n    throw TypeError(path.err);\n  }\n\n  return path.segments as PathArray;\n};\n\nexport default parsePathString;\n","/**\n * d3-polygon-area\n * https://github.com/d3/d3-polygon\n *\n * Returns the area of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns the polygon area\n */\nconst polygonArea = (polygon: [number, number][]): number => {\n  const n = polygon.length;\n  let i = -1;\n  let a;\n  let b = polygon[n - 1];\n  let area = 0;\n\n  /* eslint-disable-next-line */\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\nexport default polygonArea;\n","/**\n * Returns the square root of the distance\n * between two given points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @returns the distance value\n */\nconst distanceSquareRoot = (a: [number, number], b: [number, number]): number => {\n  return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n};\n\nexport default distanceSquareRoot;\n","import distanceSquareRoot from './distanceSquareRoot';\n\n/**\n * d3-polygon-length\n * https://github.com/d3/d3-polygon\n *\n * Returns the perimeter of a polygon.\n *\n * @param polygon an array of coordinates\n * @returns {number} the polygon length\n */\nconst polygonLength = (polygon: [number, number][]): number => {\n  return polygon.reduce((length, point, i) => {\n    if (i) {\n      return length + distanceSquareRoot(polygon[i - 1], point);\n    }\n    return 0;\n  }, 0);\n};\n\nexport default polygonLength;\n","\"use strict\";var Z=Object.defineProperty;var z=(s,t,e)=>t in s?Z(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var p=(s,t,e)=>(z(s,typeof t!=\"symbol\"?t+\"\":t,e),e);const $={a:1,b:0,c:0,d:1,e:0,f:0,m11:1,m12:0,m13:0,m14:0,m21:0,m22:1,m23:0,m24:0,m31:0,m32:0,m33:1,m34:0,m41:0,m42:0,m43:0,m44:1,is2D:!0,isIdentity:!0},E=s=>(s instanceof Float64Array||s instanceof Float32Array||Array.isArray(s)&&s.every(t=>typeof t==\"number\"))&&[6,16].some(t=>s.length===t),P=s=>s instanceof DOMMatrix||s instanceof y||typeof s==\"object\"&&Object.keys($).every(t=>s&&t in s),g=s=>{const t=new y,e=Array.from(s);if(!E(e))throw TypeError(`CSSMatrix: \"${e.join(\",\")}\" must be an array with 6/16 numbers.`);if(e.length===16){const[n,i,r,a,l,m,h,c,u,f,w,o,d,A,M,b]=e;t.m11=n,t.a=n,t.m21=l,t.c=l,t.m31=u,t.m41=d,t.e=d,t.m12=i,t.b=i,t.m22=m,t.d=m,t.m32=f,t.m42=A,t.f=A,t.m13=r,t.m23=h,t.m33=w,t.m43=M,t.m14=a,t.m24=c,t.m34=o,t.m44=b}else if(e.length===6){const[n,i,r,a,l,m]=e;t.m11=n,t.a=n,t.m12=i,t.b=i,t.m21=r,t.c=r,t.m22=a,t.d=a,t.m41=l,t.e=l,t.m42=m,t.f=m}return t},X=s=>{if(P(s))return g([s.m11,s.m12,s.m13,s.m14,s.m21,s.m22,s.m23,s.m24,s.m31,s.m32,s.m33,s.m34,s.m41,s.m42,s.m43,s.m44]);throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a DOMMatrix / CSSMatrix / JSON compatible object.`)},O=s=>{if(typeof s!=\"string\")throw TypeError(`CSSMatrix: \"${JSON.stringify(s)}\" is not a string.`);const t=String(s).replace(/\\s/g,\"\");let e=new y;const n=`CSSMatrix: invalid transform string \"${s}\"`;return t.split(\")\").filter(i=>i).forEach(i=>{const[r,a]=i.split(\"(\");if(!a)throw TypeError(n);const l=a.split(\",\").map(o=>o.includes(\"rad\")?parseFloat(o)*(180/Math.PI):parseFloat(o)),[m,h,c,u]=l,f=[m,h,c],w=[m,h,c,u];if(r===\"perspective\"&&m&&[h,c].every(o=>o===void 0))e.m34=-1/m;else if(r.includes(\"matrix\")&&[6,16].includes(l.length)&&l.every(o=>!Number.isNaN(+o))){const o=l.map(d=>Math.abs(d)<1e-6?0:d);e=e.multiply(g(o))}else if(r===\"translate3d\"&&f.every(o=>!Number.isNaN(+o)))e=e.translate(m,h,c);else if(r===\"translate\"&&m&&c===void 0)e=e.translate(m,h||0,0);else if(r===\"rotate3d\"&&w.every(o=>!Number.isNaN(+o))&&u)e=e.rotateAxisAngle(m,h,c,u);else if(r===\"rotate\"&&m&&[h,c].every(o=>o===void 0))e=e.rotate(0,0,m);else if(r===\"scale3d\"&&f.every(o=>!Number.isNaN(+o))&&f.some(o=>o!==1))e=e.scale(m,h,c);else if(r===\"scale\"&&!Number.isNaN(m)&&m!==1&&c===void 0){const d=Number.isNaN(+h)?m:h;e=e.scale(m,d,1)}else if(r===\"skew\"&&(m||!Number.isNaN(m)&&h)&&c===void 0)e=e.skew(m,h||0);else if([\"translate\",\"rotate\",\"scale\",\"skew\"].some(o=>r.includes(o))&&/[XYZ]/.test(r)&&m&&[h,c].every(o=>o===void 0))if(r===\"skewX\"||r===\"skewY\")e=e[r](m);else{const o=r.replace(/[XYZ]/,\"\"),d=r.replace(o,\"\"),A=[\"X\",\"Y\",\"Z\"].indexOf(d),M=o===\"scale\"?1:0,b=[A===0?m:M,A===1?m:M,A===2?m:M];e=e[o](...b)}else throw TypeError(n)}),e},x=(s,t)=>t?[s.a,s.b,s.c,s.d,s.e,s.f]:[s.m11,s.m12,s.m13,s.m14,s.m21,s.m22,s.m23,s.m24,s.m31,s.m32,s.m33,s.m34,s.m41,s.m42,s.m43,s.m44],Y=(s,t,e)=>{const n=new y;return n.m41=s,n.e=s,n.m42=t,n.f=t,n.m43=e,n},F=(s,t,e)=>{const n=new y,i=Math.PI/180,r=s*i,a=t*i,l=e*i,m=Math.cos(r),h=-Math.sin(r),c=Math.cos(a),u=-Math.sin(a),f=Math.cos(l),w=-Math.sin(l),o=c*f,d=-c*w;n.m11=o,n.a=o,n.m12=d,n.b=d,n.m13=u;const A=h*u*f+m*w;n.m21=A,n.c=A;const M=m*f-h*u*w;return n.m22=M,n.d=M,n.m23=-h*c,n.m31=h*w-m*u*f,n.m32=h*f+m*u*w,n.m33=m*c,n},T=(s,t,e,n)=>{const i=new y,r=Math.sqrt(s*s+t*t+e*e);if(r===0)return i;const a=s/r,l=t/r,m=e/r,h=n*(Math.PI/360),c=Math.sin(h),u=Math.cos(h),f=c*c,w=a*a,o=l*l,d=m*m,A=1-2*(o+d)*f;i.m11=A,i.a=A;const M=2*(a*l*f+m*c*u);i.m12=M,i.b=M,i.m13=2*(a*m*f-l*c*u);const b=2*(l*a*f-m*c*u);i.m21=b,i.c=b;const k=1-2*(d+w)*f;return i.m22=k,i.d=k,i.m23=2*(l*m*f+a*c*u),i.m31=2*(m*a*f+l*c*u),i.m32=2*(m*l*f-a*c*u),i.m33=1-2*(w+o)*f,i},I=(s,t,e)=>{const n=new y;return n.m11=s,n.a=s,n.m22=t,n.d=t,n.m33=e,n},v=(s,t)=>{const e=new y;if(s){const n=s*Math.PI/180,i=Math.tan(n);e.m21=i,e.c=i}if(t){const n=t*Math.PI/180,i=Math.tan(n);e.m12=i,e.b=i}return e},R=s=>v(s,0),D=s=>v(0,s),N=(s,t)=>{const e=t.m11*s.m11+t.m12*s.m21+t.m13*s.m31+t.m14*s.m41,n=t.m11*s.m12+t.m12*s.m22+t.m13*s.m32+t.m14*s.m42,i=t.m11*s.m13+t.m12*s.m23+t.m13*s.m33+t.m14*s.m43,r=t.m11*s.m14+t.m12*s.m24+t.m13*s.m34+t.m14*s.m44,a=t.m21*s.m11+t.m22*s.m21+t.m23*s.m31+t.m24*s.m41,l=t.m21*s.m12+t.m22*s.m22+t.m23*s.m32+t.m24*s.m42,m=t.m21*s.m13+t.m22*s.m23+t.m23*s.m33+t.m24*s.m43,h=t.m21*s.m14+t.m22*s.m24+t.m23*s.m34+t.m24*s.m44,c=t.m31*s.m11+t.m32*s.m21+t.m33*s.m31+t.m34*s.m41,u=t.m31*s.m12+t.m32*s.m22+t.m33*s.m32+t.m34*s.m42,f=t.m31*s.m13+t.m32*s.m23+t.m33*s.m33+t.m34*s.m43,w=t.m31*s.m14+t.m32*s.m24+t.m33*s.m34+t.m34*s.m44,o=t.m41*s.m11+t.m42*s.m21+t.m43*s.m31+t.m44*s.m41,d=t.m41*s.m12+t.m42*s.m22+t.m43*s.m32+t.m44*s.m42,A=t.m41*s.m13+t.m42*s.m23+t.m43*s.m33+t.m44*s.m43,M=t.m41*s.m14+t.m42*s.m24+t.m43*s.m34+t.m44*s.m44;return g([e,n,i,r,a,l,m,h,c,u,f,w,o,d,A,M])};class y{constructor(t){return this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0,this.m11=1,this.m12=0,this.m13=0,this.m14=0,this.m21=0,this.m22=1,this.m23=0,this.m24=0,this.m31=0,this.m32=0,this.m33=1,this.m34=0,this.m41=0,this.m42=0,this.m43=0,this.m44=1,t?this.setMatrixValue(t):this}get isIdentity(){return this.m11===1&&this.m12===0&&this.m13===0&&this.m14===0&&this.m21===0&&this.m22===1&&this.m23===0&&this.m24===0&&this.m31===0&&this.m32===0&&this.m33===1&&this.m34===0&&this.m41===0&&this.m42===0&&this.m43===0&&this.m44===1}get is2D(){return this.m31===0&&this.m32===0&&this.m33===1&&this.m34===0&&this.m43===0&&this.m44===1}setMatrixValue(t){return typeof t==\"string\"&&t.length&&t!==\"none\"?O(t):Array.isArray(t)||t instanceof Float64Array||t instanceof Float32Array?g(t):typeof t==\"object\"?X(t):this}toFloat32Array(t){return Float32Array.from(x(this,t))}toFloat64Array(t){return Float64Array.from(x(this,t))}toString(){const{is2D:t}=this,e=this.toFloat64Array(t).join(\", \");return`${t?\"matrix\":\"matrix3d\"}(${e})`}toJSON(){const{is2D:t,isIdentity:e}=this;return{...this,is2D:t,isIdentity:e}}multiply(t){return N(this,t)}translate(t,e,n){const i=t;let r=e,a=n;return typeof r>\"u\"&&(r=0),typeof a>\"u\"&&(a=0),N(this,Y(i,r,a))}scale(t,e,n){const i=t;let r=e,a=n;return typeof r>\"u\"&&(r=t),typeof a>\"u\"&&(a=1),N(this,I(i,r,a))}rotate(t,e,n){let i=t,r=e||0,a=n||0;return typeof t==\"number\"&&typeof e>\"u\"&&typeof n>\"u\"&&(a=i,i=0,r=0),N(this,F(i,r,a))}rotateAxisAngle(t,e,n,i){if([t,e,n,i].some(r=>Number.isNaN(+r)))throw new TypeError(\"CSSMatrix: expecting 4 values\");return N(this,T(t,e,n,i))}skewX(t){return N(this,R(t))}skewY(t){return N(this,D(t))}skew(t,e){return N(this,v(t,e))}transformPoint(t){const e=this.m11*t.x+this.m21*t.y+this.m31*t.z+this.m41*t.w,n=this.m12*t.x+this.m22*t.y+this.m32*t.z+this.m42*t.w,i=this.m13*t.x+this.m23*t.y+this.m33*t.z+this.m43*t.w,r=this.m14*t.x+this.m24*t.y+this.m34*t.z+this.m44*t.w;return t instanceof DOMPoint?new DOMPoint(e,n,i,r):{x:e,y:n,z:i,w:r}}}p(y,\"Translate\",Y),p(y,\"Rotate\",F),p(y,\"RotateAxisAngle\",T),p(y,\"Scale\",I),p(y,\"SkewX\",R),p(y,\"SkewY\",D),p(y,\"Skew\",v),p(y,\"Multiply\",N),p(y,\"fromArray\",g),p(y,\"fromMatrix\",X),p(y,\"fromString\",O),p(y,\"toArray\",x),p(y,\"isCompatibleArray\",E),p(y,\"isCompatibleObject\",P);module.exports=y;\n//# sourceMappingURL=dommatrix.cjs.map\n","import type { AbsoluteArray } from '../types';\nimport isPathArray from './isPathArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all absolute values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isAbsoluteArray = (path: unknown): path is AbsoluteArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` also checks if it's `Array`\n    path.every(([x]) => x === x.toUpperCase())\n  );\n};\nexport default isAbsoluteArray;\n","import parsePathString from '../parser/parsePathString';\nimport isAbsoluteArray from '../util/isAbsoluteArray';\nimport type {\n  PathArray,\n  AbsoluteArray,\n  AbsoluteCommand,\n  AbsoluteSegment,\n  VSegment,\n  HSegment,\n  QSegment,\n  TSegment,\n  ASegment,\n  SSegment,\n  CSegment,\n  MSegment,\n} from '../types';\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to absolute values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with absolute values\n */\nconst pathToAbsolute = (pathInput: string | PathArray): AbsoluteArray => {\n  /* istanbul ignore else */\n  if (isAbsoluteArray(pathInput)) {\n    return [...pathInput];\n  }\n\n  const path = parsePathString(pathInput);\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  // the `absoluteSegment[]` is for sure an `absolutePath`\n  return path.map(segment => {\n    const values = segment.slice(1).map(Number);\n    const [pathCommand] = segment;\n    const absCommand = pathCommand.toUpperCase() as AbsoluteCommand;\n\n    if (pathCommand === 'M') {\n      [x, y] = values;\n      mx = x;\n      my = y;\n      return ['M', x, y] as MSegment;\n    }\n\n    let absoluteSegment = [] as unknown as AbsoluteSegment;\n\n    if (pathCommand !== absCommand) {\n      if (absCommand === 'A') {\n        absoluteSegment = [\n          absCommand,\n          values[0],\n          values[1],\n          values[2],\n          values[3],\n          values[4],\n          values[5] + x,\n          values[6] + y,\n        ] as ASegment;\n      } else if (absCommand === 'V') {\n        absoluteSegment = [absCommand, values[0] + y] as VSegment;\n      } else if (absCommand === 'H') {\n        absoluteSegment = [absCommand, values[0] + x] as HSegment;\n      } else {\n        // use brakets for `eslint: no-case-declaration`\n        // https://stackoverflow.com/a/50753272/803358\n        const absValues = values.map((n, j) => n + (j % 2 ? y : x));\n        // for n, l, c, s, q, t\n        absoluteSegment = [absCommand, ...absValues] as QSegment | TSegment | SSegment | CSegment;\n      }\n    } else {\n      absoluteSegment = [absCommand, ...values] as typeof segment;\n    }\n\n    // const segLength = absoluteSegment.length;\n    if (absCommand === 'Z') {\n      x = mx;\n      y = my;\n    } else if (absCommand === 'H') {\n      [, x] = absoluteSegment as HSegment;\n    } else if (absCommand === 'V') {\n      [, y] = absoluteSegment as VSegment;\n    } else {\n      // x = absoluteSegment[segLength - 2];\n      // y = absoluteSegment[segLength - 1];\n      [x, y] = absoluteSegment.slice(-2) as [number, number];\n\n      if (absCommand === 'M') {\n        mx = x;\n        my = y;\n      }\n    }\n\n    return absoluteSegment;\n  }) as AbsoluteArray;\n};\nexport default pathToAbsolute;\n","import type { ParserParams } from '../interface';\nimport type { NormalSegment, PathSegment } from '../types';\n\n/**\n * Normalizes a single segment of a `pathArray` object.\n *\n * @param segment the segment object\n * @param params the coordinates of the previous segment\n * @returns the normalized segment\n */\nconst normalizeSegment = (segment: PathSegment, params: ParserParams): NormalSegment => {\n  const [pathCommand] = segment;\n  const { x1: px1, y1: py1, x2: px2, y2: py2 } = params;\n  const values = segment.slice(1).map(Number);\n  let result = segment;\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'H') {\n    result = ['L', segment[1], py1];\n  } else if (pathCommand === 'V') {\n    result = ['L', px1, segment[1]];\n  } else if (pathCommand === 'S') {\n    const x1 = px1 * 2 - px2;\n    const y1 = py1 * 2 - py2;\n    params.x1 = x1;\n    params.y1 = y1;\n    result = ['C', x1, y1, ...(values as [number, number, number, number])];\n  } else if (pathCommand === 'T') {\n    const qx = px1 * 2 - (params.qx ? params.qx : /* istanbul ignore next */ 0);\n    const qy = py1 * 2 - (params.qy ? params.qy : /* istanbul ignore next */ 0);\n    params.qx = qx;\n    params.qy = qy;\n    result = ['Q', qx, qy, ...(values as [number, number])];\n  } else if (pathCommand === 'Q') {\n    const [nqx, nqy] = values as [number, number];\n    params.qx = nqx;\n    params.qy = nqy;\n  }\n\n  return result as NormalSegment;\n};\nexport default normalizeSegment;\n","import type { NormalArray } from '../types';\nimport isAbsoluteArray from './isAbsoluteArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all segments are in non-shorthand notation\n * with absolute values.\n *\n * @param {string | SVGPath.pathArray} path the `pathArray` to be checked\n * @returns {boolean} iteration result\n */\nconst isNormalizedArray = (path: unknown): path is NormalArray => {\n  // `isAbsoluteArray` also checks if it's `Array`\n  return isAbsoluteArray(path) && path.every(([pc]) => 'ACLMQZ'.includes(pc));\n};\nexport default isNormalizedArray;\n","import type { ParserParams } from '../interface';\n\nconst paramsParser: ParserParams = {\n  x1: 0,\n  y1: 0,\n  x2: 0,\n  y2: 0,\n  x: 0,\n  y: 0,\n  qx: null,\n  qy: null,\n};\n\nexport default paramsParser;\n","import pathToAbsolute from '../convert/pathToAbsolute';\nimport normalizeSegment from './normalizeSegment';\nimport isNormalizedArray from '../util/isNormalizedArray';\nimport paramsParser from '../parser/paramsParser';\nimport type { NormalArray, PathArray } from '../types';\n\n/**\n * Normalizes a `path` object for further processing:\n * * convert segments to absolute values\n * * convert shorthand path commands to their non-shorthand notation\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the normalized `pathArray`\n */\nconst normalizePath = (pathInput: string | PathArray): NormalArray => {\n  if (isNormalizedArray(pathInput)) {\n    return [...pathInput];\n  }\n\n  const path = pathToAbsolute(pathInput);\n  const params = { ...paramsParser };\n  const allPathCommands = [];\n  const ii = path.length;\n  let pathCommand = '';\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    path[i] = normalizeSegment(path[i], params);\n\n    const segment = path[i];\n    const seglen = segment.length;\n\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n  }\n\n  return path as NormalArray;\n};\nexport default normalizePath;\n","/**\n * Returns the coordinates of a specified distance\n * ratio between two points.\n *\n * @param a the first point coordinates\n * @param b the second point coordinates\n * @param t the ratio\n * @returns the midpoint coordinates\n */\nconst midPoint = (a: [number, number], b: [number, number], t: number): [number, number] => {\n  const [ax, ay] = a;\n  const [bx, by] = b;\n  return [ax + (bx - ax) * t, ay + (by - ay) * t];\n};\n\nexport default midPoint;\n","import midPoint from '../math/midPoint';\nimport distanceSquareRoot from '../math/distanceSquareRoot';\nimport type { LengthFactory } from '../interface';\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point\n * @returns the segment length, point, min & max\n */\nconst segmentLineFactory = (x1: number, y1: number, x2: number, y2: number, distance?: number): LengthFactory => {\n  const length = distanceSquareRoot([x1, y1], [x2, y2]);\n  let point = { x: 0, y: 0 };\n\n  /* istanbul ignore else */\n  if (typeof distance === 'number') {\n    if (distance <= 0) {\n      point = { x: x1, y: y1 };\n    } else if (distance >= length) {\n      point = { x: x2, y: y2 };\n    } else {\n      const [x, y] = midPoint([x1, y1], [x2, y2], distance / length);\n      point = { x, y };\n    }\n  }\n\n  return {\n    length,\n    point,\n    min: {\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n    },\n    max: {\n      x: Math.max(x1, x2),\n      y: Math.max(y1, y2),\n    },\n  };\n};\nexport default segmentLineFactory;\n","import type { LengthFactory } from '../interface';\nimport segmentLineFactory from './segmentLineFactory';\nimport distanceSquareRoot from '../math/distanceSquareRoot';\n\n/**\n * Returns an angle value between two points.\n *\n * @param v0\n * @param v1\n * @returns a number representing an angle\n */\nconst angleBetween = (v0: { x: number; y: number }, v1: { x: number; y: number }): number => {\n  const { x: v0x, y: v0y } = v0;\n  const { x: v1x, y: v1y } = v1;\n  const p = v0x * v1x + v0y * v1y;\n  const n = Math.sqrt((v0x ** 2 + v0y ** 2) * (v1x ** 2 + v1y ** 2));\n  const sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;\n  const angle = sign * Math.acos(p / n);\n\n  return angle;\n};\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n *\n * @see https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n *\n * @param x1 the starting x position\n * @param y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param x the ending x position\n * @param y the ending y position\n * @param t the point distance\n * @returns the requested point\n */\nconst getPointAtArcSegmentLength = (\n  x1: number,\n  y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  x: number,\n  y: number,\n  t: number,\n): { x: number; y: number } => {\n  const { abs, sin, cos, sqrt, PI } = Math;\n  let rx = abs(RX);\n  let ry = abs(RY);\n  const xRot = ((angle % 360) + 360) % 360;\n  const xRotRad = xRot * (PI / 180);\n\n  if (x1 === x && y1 === y) {\n    return { x: x1, y: y1 };\n  }\n\n  if (rx === 0 || ry === 0) {\n    return segmentLineFactory(x1, y1, x, y, t).point;\n  }\n\n  const dx = (x1 - x) / 2;\n  const dy = (y1 - y) / 2;\n\n  const transformedPoint = {\n    x: cos(xRotRad) * dx + sin(xRotRad) * dy,\n    y: -sin(xRotRad) * dx + cos(xRotRad) * dy,\n  };\n\n  const radiiCheck = transformedPoint.x ** 2 / rx ** 2 + transformedPoint.y ** 2 / ry ** 2;\n\n  if (radiiCheck > 1) {\n    rx *= sqrt(radiiCheck);\n    ry *= sqrt(radiiCheck);\n  }\n\n  const cSquareNumerator = rx ** 2 * ry ** 2 - rx ** 2 * transformedPoint.y ** 2 - ry ** 2 * transformedPoint.x ** 2;\n\n  const cSquareRootDenom = rx ** 2 * transformedPoint.y ** 2 + ry ** 2 * transformedPoint.x ** 2;\n\n  let cRadicand = cSquareNumerator / cSquareRootDenom;\n  cRadicand = cRadicand < 0 ? 0 : cRadicand;\n  const cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);\n  const transformedCenter = {\n    x: cCoef * ((rx * transformedPoint.y) / ry),\n    y: cCoef * (-(ry * transformedPoint.x) / rx),\n  };\n\n  const center = {\n    x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,\n    y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2,\n  };\n\n  const startVector = {\n    x: (transformedPoint.x - transformedCenter.x) / rx,\n    y: (transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  const startAngle = angleBetween({ x: 1, y: 0 }, startVector);\n\n  const endVector = {\n    x: (-transformedPoint.x - transformedCenter.x) / rx,\n    y: (-transformedPoint.y - transformedCenter.y) / ry,\n  };\n\n  let sweepAngle = angleBetween(startVector, endVector);\n  if (!SF && sweepAngle > 0) {\n    sweepAngle -= 2 * PI;\n  } else if (SF && sweepAngle < 0) {\n    sweepAngle += 2 * PI;\n  }\n  sweepAngle %= 2 * PI;\n\n  const alpha = startAngle + sweepAngle * t;\n  const ellipseComponentX = rx * cos(alpha);\n  const ellipseComponentY = ry * sin(alpha);\n\n  const point = {\n    x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,\n    y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y,\n  };\n\n  // to be used later\n  // point.ellipticalArcStartAngle = startAngle;\n  // point.ellipticalArcEndAngle = startAngle + sweepAngle;\n  // point.ellipticalArcAngle = alpha;\n\n  // point.ellipticalArcCenter = center;\n  // point.resultantRx = rx;\n  // point.resultantRy = ry;\n\n  return point;\n};\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the shape minimum and maximum {x,y} coordinates of an A (arc-to) segment.\n *\n * @param X1 the starting x position\n * @param Y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param X2 the ending x position\n * @param Y2 the ending y position\n * @param distance the point distance\n * @returns the segment length, point, min & max\n */\nconst segmentArcFactory = (\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  distance: number,\n): LengthFactory => {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = X1;\n  let y = Y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y] as [number, number];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: X2, y: Y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map(n => n.x)),\n      y: Math.min(...POINTS.map(n => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map(n => n.x)),\n      y: Math.max(...POINTS.map(n => n.y)),\n    },\n  };\n};\nexport default segmentArcFactory;\n","import { LengthFactory } from 'src/interface';\nimport distanceSquareRoot from '../math/distanceSquareRoot';\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the point at cubic-bezier segment length\n */\nconst getPointAtCubicSegmentLength = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n  t: number,\n): { x: number; y: number } => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 3 * x1 + 3 * t1 ** 2 * t * c1x + 3 * t1 * t ** 2 * c2x + t ** 3 * x2,\n    y: t1 ** 3 * y1 + 3 * t1 ** 2 * t * c1y + 3 * t1 * t ** 2 * c2y + t ** 3 * y2,\n  };\n};\n\n/**\n * Returns the length of a C (cubic-bezier) segment\n * or an {x,y} point at a given length.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the point distance\n * @returns the segment length, point, min & max\n */\nconst segmentCubicFactory = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n): LengthFactory => {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1;\n  let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y] as [number, number];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: x2, y: y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map(n => n.x)),\n      y: Math.min(...POINTS.map(n => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map(n => n.x)),\n      y: Math.max(...POINTS.map(n => n.y)),\n    },\n  };\n};\nexport default segmentCubicFactory;\n","import { LengthFactory } from 'src/interface';\nimport distanceSquareRoot from '../math/distanceSquareRoot';\n\n/**\n * Returns the {x,y} coordinates of a point at a\n * given length of a quadratic-bezier segment.\n *\n * @see https://github.com/substack/point-at-length\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param cx the control point X\n * @param cy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param t a [0-1] ratio\n * @returns the requested {x,y} coordinates\n */\nconst getPointAtQuadSegmentLength = (\n  x1: number,\n  y1: number,\n  cx: number,\n  cy: number,\n  x2: number,\n  y2: number,\n  t: number,\n): { x: number; y: number } => {\n  const t1 = 1 - t;\n  return {\n    x: t1 ** 2 * x1 + 2 * t1 * t * cx + t ** 2 * x2,\n    y: t1 ** 2 * y1 + 2 * t1 * t * cy + t ** 2 * y2,\n  };\n};\n\n/**\n * Returns a {x,y} point at a given length, the total length and\n * the minimum and maximum {x,y} coordinates of a Q (quadratic-bezier) segment.\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param qx the control point X\n * @param qy the control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @param distance the distance to point\n * @returns the segment length, point, min & max\n */\nconst segmentQuadFactory = (\n  x1: number,\n  y1: number,\n  qx: number,\n  qy: number,\n  x2: number,\n  y2: number,\n  distance?: number,\n): LengthFactory => {\n  const distanceIsNumber = typeof distance === 'number';\n  let x = x1;\n  let y = y1;\n  let LENGTH = 0;\n  let prev = [x, y, LENGTH];\n  let cur = [x, y] as [number, number];\n  let t = 0;\n  let POINT = { x: 0, y: 0 };\n  let POINTS = [{ x, y }];\n\n  if (distanceIsNumber && distance <= 0) {\n    POINT = { x, y };\n  }\n\n  const sampleSize = 300;\n  for (let j = 0; j <= sampleSize; j += 1) {\n    t = j / sampleSize;\n\n    ({ x, y } = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t));\n    POINTS = [...POINTS, { x, y }];\n    LENGTH += distanceSquareRoot(cur, [x, y]);\n    cur = [x, y];\n\n    if (distanceIsNumber && LENGTH > distance && distance > prev[2]) {\n      const dv = (LENGTH - distance) / (LENGTH - prev[2]);\n\n      POINT = {\n        x: cur[0] * (1 - dv) + prev[0] * dv,\n        y: cur[1] * (1 - dv) + prev[1] * dv,\n      };\n    }\n    prev = [x, y, LENGTH];\n  }\n\n  /* istanbul ignore else */\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x: x2, y: y2 };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...POINTS.map(n => n.x)),\n      y: Math.min(...POINTS.map(n => n.y)),\n    },\n    max: {\n      x: Math.max(...POINTS.map(n => n.x)),\n      y: Math.max(...POINTS.map(n => n.y)),\n    },\n  };\n};\nexport default segmentQuadFactory;\n","import type { MSegment, PathArray } from '../types';\nimport type { LengthFactory } from '../interface';\nimport normalizePath from '../process/normalizePath';\nimport segmentLineFactory from './segmentLineFactory';\nimport segmentArcFactory from './segmentArcFactory';\nimport segmentCubicFactory from './segmentCubicFactory';\nimport segmentQuadFactory from './segmentQuadFactory';\n\n/**\n * Returns a {x,y} point at a given length\n * of a shape, the shape total length and\n * the shape minimum and maximum {x,y} coordinates.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the path length, point, min & max\n */\nconst pathLengthFactory = (pathInput: string | PathArray, distance?: number): LengthFactory => {\n  const path = normalizePath(pathInput);\n  const distanceIsNumber = typeof distance === 'number';\n  let isM;\n  let data = [] as number[];\n  let pathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let seg;\n  let MIN = [] as { x: number; y: number }[];\n  let MAX = [] as { x: number; y: number }[];\n  let length = 0;\n  let min = { x: 0, y: 0 };\n  let max = min;\n  let point = min;\n  let POINT = min;\n  let LENGTH = 0;\n\n  for (let i = 0, ll = path.length; i < ll; i += 1) {\n    seg = path[i];\n    [pathCommand] = seg;\n    isM = pathCommand === 'M';\n    data = !isM ? [x, y, ...(seg.slice(1) as number[])] : data;\n\n    // this segment is always ZERO\n    /* istanbul ignore else */\n    if (isM) {\n      // remember mx, my for Z\n      [, mx, my] = seg as MSegment;\n      min = { x: mx, y: my };\n      max = min;\n      length = 0;\n\n      if (distanceIsNumber && distance < 0.001) {\n        POINT = min;\n      }\n    } else if (pathCommand === 'L') {\n      ({ length, min, max, point } = segmentLineFactory(\n        ...(data as [number, number, number, number]),\n        (distance || 0) - LENGTH,\n      ));\n    } else if (pathCommand === 'A') {\n      ({ length, min, max, point } = segmentArcFactory(\n        ...(data as [number, number, number, number, number, number, number, number, number]),\n        (distance || 0) - LENGTH,\n      ));\n    } else if (pathCommand === 'C') {\n      ({ length, min, max, point } = segmentCubicFactory(\n        ...(data as [number, number, number, number, number, number, number]),\n        (distance || 0) - LENGTH,\n      ));\n    } else if (pathCommand === 'Q') {\n      ({ length, min, max, point } = segmentQuadFactory(\n        ...(data as [number, number, number, number, number, number]),\n        (distance || 0) - LENGTH,\n      ));\n    } else if (pathCommand === 'Z') {\n      data = [x, y, mx, my];\n      ({ length, min, max, point } = segmentLineFactory(\n        ...(data as [number, number, number, number]),\n        (distance || 0) - LENGTH,\n      ));\n    }\n\n    if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {\n      POINT = point;\n    }\n\n    MAX = [...MAX, max];\n    MIN = [...MIN, min];\n    LENGTH += length;\n\n    [x, y] = pathCommand !== 'Z' ? (seg.slice(-2) as [number, number]) : [mx, my];\n  }\n\n  // native `getPointAtLength` behavior when the given distance\n  // is higher than total length\n  if (distanceIsNumber && distance >= LENGTH) {\n    POINT = { x, y };\n  }\n\n  return {\n    length: LENGTH,\n    point: POINT,\n    min: {\n      x: Math.min(...MIN.map(n => n.x)),\n      y: Math.min(...MIN.map(n => n.y)),\n    },\n    max: {\n      x: Math.max(...MAX.map(n => n.x)),\n      y: Math.max(...MAX.map(n => n.y)),\n    },\n  };\n};\nexport default pathLengthFactory;\n","import { PathBBox } from 'src/interface';\nimport { PathArray } from 'src/types';\nimport pathLengthFactory from './pathLengthFactory';\n\n/**\n * Returns the bounding box of a shape.\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathBBox = (path?: PathArray | string): PathBBox => {\n  if (!path) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      x2: 0,\n      y2: 0,\n      cx: 0,\n      cy: 0,\n      cz: 0,\n    };\n  }\n\n  const {\n    min: { x: xMin, y: yMin },\n    max: { x: xMax, y: yMax },\n  } = pathLengthFactory(path);\n\n  const width = xMax - xMin;\n  const height = yMax - yMin;\n\n  return {\n    width,\n    height,\n    x: xMin,\n    y: yMin,\n    x2: xMax,\n    y2: yMax,\n    cx: xMin + width / 2,\n    cy: yMin + height / 2,\n    // an estimted guess\n    cz: Math.max(width, height) + Math.min(width, height) / 2,\n  };\n};\nexport default getPathBBox;\n","import { CSegment, PathArray, PathCommand } from '../types';\n\n/**\n * Splits an extended A (arc-to) segment into two cubic-bezier segments.\n *\n * @param path the `pathArray` this segment belongs to\n * @param allPathCommands all previous path commands\n * @param i the segment index\n */\nconst fixArc = (path: PathArray, allPathCommands: PathCommand[], i: number) => {\n  if (path[i].length > 7) {\n    path[i].shift();\n    const segment = path[i];\n    let ni = i; // ESLint\n    while (segment.length) {\n      // if created multiple C:s, their original seg is saved\n      allPathCommands[i] = 'A';\n      path.splice((ni += 1), 0, ['C', ...segment.splice(0, 6)] as CSegment);\n    }\n    path.splice(i, 1);\n  }\n};\nexport default fixArc;\n","import { CurveArray } from '../types';\nimport isNormalizedArray from './isNormalizedArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with all C (cubic bezier) segments.\n *\n * @param path the `Array` to be checked\n * @returns iteration result\n */\nconst isCurveArray = (path: unknown): path is CurveArray => {\n  // `isPathArray` also checks if it's `Array`\n  return isNormalizedArray(path) && path.every(([pc]) => 'MC'.includes(pc));\n};\nexport default isCurveArray;\n","/**\n * Returns an {x,y} vector rotated by a given\n * angle in radian.\n *\n * @param x the initial vector x\n * @param y the initial vector y\n * @param rad the radian vector angle\n * @returns the rotated vector\n */\nconst rotateVector = (x: number, y: number, rad: number): { x: number; y: number } => {\n  const X = x * Math.cos(rad) - y * Math.sin(rad);\n  const Y = x * Math.sin(rad) + y * Math.cos(rad);\n  return { x: X, y: Y };\n};\n\nexport default rotateVector;\n","import rotateVector from '../math/rotateVector';\n\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n *\n * @param X1 the starting x position\n * @param Y1 the starting y position\n * @param RX x-radius of the arc\n * @param RY y-radius of the arc\n * @param angle x-axis-rotation of the arc\n * @param LAF large-arc-flag of the arc\n * @param SF sweep-flag of the arc\n * @param X2 the ending x position\n * @param Y2 the ending y position\n * @param recursive the parameters needed to split arc into 2 segments\n * @return the resulting cubic-bezier segment(s)\n */\nconst arcToCubic = (\n  X1: number,\n  Y1: number,\n  RX: number,\n  RY: number,\n  angle: number,\n  LAF: number,\n  SF: number,\n  X2: number,\n  Y2: number,\n  recursive?: [number, number, number, number],\n): number[] => {\n  let x1 = X1;\n  let y1 = Y1;\n  let rx = RX;\n  let ry = RY;\n  let x2 = X2;\n  let y2 = Y2;\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const d120 = (Math.PI * 120) / 180;\n\n  const rad = (Math.PI / 180) * (+angle || 0);\n  let res = [] as number[];\n  let xy;\n  let f1;\n  let f2;\n  let cx;\n  let cy;\n\n  if (!recursive) {\n    xy = rotateVector(x1, y1, -rad);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotateVector(x2, y2, -rad);\n    x2 = xy.x;\n    y2 = xy.y;\n\n    const x = (x1 - x2) / 2;\n    const y = (y1 - y2) / 2;\n    let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx *= h;\n      ry *= h;\n    }\n    const rx2 = rx * rx;\n    const ry2 = ry * ry;\n\n    const k =\n      (LAF === SF ? -1 : 1) *\n      Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n\n    cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f1 = Math.asin(((((y1 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n    // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n    f2 = Math.asin(((((y2 - cy) / ry) * 10 ** 9) >> 0) / 10 ** 9);\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    if (f1 < 0) f1 = Math.PI * 2 + f1;\n    if (f2 < 0) f2 = Math.PI * 2 + f2;\n    if (SF && f1 > f2) {\n      f1 -= Math.PI * 2;\n    }\n    if (!SF && f2 > f1) {\n      f2 -= Math.PI * 2;\n    }\n  } else {\n    [f1, f2, cx, cy] = recursive;\n  }\n  let df = f2 - f1;\n  if (Math.abs(df) > d120) {\n    const f2old = f2;\n    const x2old = x2;\n    const y2old = y2;\n    f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  const c1 = Math.cos(f1);\n  const s1 = Math.sin(f1);\n  const c2 = Math.cos(f2);\n  const s2 = Math.sin(f2);\n  const t = Math.tan(df / 4);\n  const hx = (4 / 3) * rx * t;\n  const hy = (4 / 3) * ry * t;\n  const m1 = [x1, y1];\n  const m2 = [x1 + hx * s1, y1 - hy * c1];\n  const m3 = [x2 + hx * s2, y2 - hy * c2];\n  const m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n  if (recursive) {\n    return [...m2, ...m3, ...m4, ...res];\n  }\n  res = [...m2, ...m3, ...m4, ...res];\n  const newres = [];\n  for (let i = 0, ii = res.length; i < ii; i += 1) {\n    newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;\n  }\n  return newres;\n};\nexport default arcToCubic;\n","/**\n * Converts a Q (quadratic-bezier) segment to C (cubic-bezier).\n *\n * @param x1 curve start x\n * @param y1 curve start y\n * @param qx control point x\n * @param qy control point y\n * @param x2 curve end x\n * @param y2 curve end y\n * @returns the cubic-bezier segment\n */\nconst quadToCubic = (\n  x1: number,\n  y1: number,\n  qx: number,\n  qy: number,\n  x2: number,\n  y2: number,\n): [number, number, number, number, number, number] => {\n  const r13 = 1 / 3;\n  const r23 = 2 / 3;\n  return [\n    r13 * x1 + r23 * qx, // cpx1\n    r13 * y1 + r23 * qy, // cpy1\n    r13 * x2 + r23 * qx, // cpx2\n    r13 * y2 + r23 * qy, // cpy2\n    x2,\n    y2, // x,y\n  ];\n};\nexport default quadToCubic;\n","import midPoint from '../math/midPoint';\n\n/**\n * Converts an L (line-to) segment to C (cubic-bezier).\n *\n * @param x1 line start x\n * @param y1 line start y\n * @param x2 line end x\n * @param y2 line end y\n * @returns the cubic-bezier segment\n */\nconst lineToCubic = (x1: number, y1: number, x2: number, y2: number) => {\n  const t = 0.5;\n  const mid = midPoint([x1, y1], [x2, y2], t);\n  return [...mid, x2, y2, x2, y2];\n};\nexport default lineToCubic;\n","import arcToCubic from './arcToCubic';\nimport quadToCubic from './quadToCubic';\nimport lineToCubic from './lineToCubic';\nimport type { CSegment, MSegment, PathSegment } from '../types';\nimport type { ParserParams } from '../interface';\n\n/**\n * Converts any segment to C (cubic-bezier).\n *\n * @param segment the source segment\n * @param params the source segment parameters\n * @returns the cubic-bezier segment\n */\nconst segmentToCubic = (segment: PathSegment, params: ParserParams): MSegment | CSegment => {\n  const [pathCommand] = segment;\n  const values = segment.slice(1).map(Number);\n  const [x, y] = values;\n  let args;\n  const { x1: px1, y1: py1, x: px, y: py } = params;\n\n  if (!'TQ'.includes(pathCommand)) {\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (pathCommand === 'M') {\n    params.x = x;\n    params.y = y;\n    return segment;\n  } else if (pathCommand === 'A') {\n    args = [px1, py1, ...values] as [number, number, number, number, number, number, number, number, number];\n    return ['C', ...arcToCubic(...args)] as CSegment;\n  } else if (pathCommand === 'Q') {\n    params.qx = x;\n    params.qy = y;\n    args = [px1, py1, ...values] as [number, number, number, number, number, number];\n    return ['C', ...quadToCubic(...args)] as CSegment;\n  } else if (pathCommand === 'L') {\n    return ['C', ...lineToCubic(px1, py1, x, y)] as CSegment;\n  } else if (pathCommand === 'Z') {\n    return ['C', ...lineToCubic(px1, py1, px, py)] as CSegment;\n  }\n\n  return segment as MSegment | CSegment;\n};\nexport default segmentToCubic;\n","import fixArc from '../process/fixArc';\nimport isCurveArray from '../util/isCurveArray';\nimport normalizePath from '../process/normalizePath';\nimport segmentToCubic from '../process/segmentToCubic';\nimport paramsParser from '../parser/paramsParser';\nimport { CurveArray, PathArray, PathCommand } from '../types';\n\n/**\n * Parses a path string value or 'pathArray' and returns a new one\n * in which all segments are converted to cubic-bezier.\n *\n * In addition, un-necessary `Z` segment is removed if previous segment\n * extends to the `M` segment.\n *\n * @param pathInput the string to be parsed or 'pathArray'\n * @returns the resulted `pathArray` converted to cubic-bezier\n */\nconst pathToCurve = (pathInput: string | PathArray): CurveArray => {\n  /* istanbul ignore else */\n  if (isCurveArray(pathInput)) {\n    return [...pathInput];\n  }\n\n  const path = normalizePath(pathInput);\n  const params = { ...paramsParser };\n  const allPathCommands = [] as PathCommand[];\n  let pathCommand = ''; // ts-lint\n  let ii = path.length;\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n    allPathCommands[i] = pathCommand as PathCommand;\n\n    path[i] = segmentToCubic(path[i], params);\n\n    fixArc(path, allPathCommands, i);\n    ii = path.length;\n\n    const segment = path[i];\n    const seglen = segment.length;\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n  }\n\n  return path as CurveArray;\n};\nexport default pathToCurve;\n","import pathToCurve from '../convert/pathToCurve';\nimport type { PathArray } from '../types';\n\n/**\n * Returns the area of a single cubic-bezier segment.\n *\n * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html\n *\n * @param x1 the starting point X\n * @param y1 the starting point Y\n * @param c1x the first control point X\n * @param c1y the first control point Y\n * @param c2x the second control point X\n * @param c2y the second control point Y\n * @param x2 the ending point X\n * @param y2 the ending point Y\n * @returns the area of the cubic-bezier segment\n */\nconst getCubicSegArea = (\n  x1: number,\n  y1: number,\n  c1x: number,\n  c1y: number,\n  c2x: number,\n  c2y: number,\n  x2: number,\n  y2: number,\n) => {\n  return (\n    (3 *\n      ((y2 - y1) * (c1x + c2x) -\n        (x2 - x1) * (c1y + c2y) +\n        c1y * (x1 - c2x) -\n        c1x * (y1 - c2y) +\n        y2 * (c2x + x1 / 3) -\n        x2 * (c2y + y1 / 3))) /\n    20\n  );\n};\n\n/**\n * Returns the area of a shape.\n *\n * @author Jürg Lehni & Jonathan Puckey\n *\n * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js\n *\n * @param path the shape `pathArray`\n * @returns the length of the cubic-bezier segment\n */\nconst getPathArea = (path: PathArray) => {\n  let x = 0;\n  let y = 0;\n  let len = 0;\n\n  return pathToCurve(path)\n    .map(seg => {\n      switch (seg[0]) {\n        case 'M':\n          [, x, y] = seg;\n          return 0;\n        default:\n          len = getCubicSegArea(x, y, ...(seg.slice(1) as [number, number, number, number, number, number]));\n          [x, y] = seg.slice(-2) as [number, number];\n          return len;\n      }\n    })\n    .reduce((a, b) => a + b, 0);\n};\nexport default getPathArea;\n","import type { PathArray } from '../types';\nimport pathLengthFactory from './pathLengthFactory';\n\n/**\n * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.\n *\n * The `normalizePath` version is lighter, faster, more efficient and more accurate\n * with paths that are not `curveArray`.\n *\n * @param pathInput the target `pathArray`\n * @returns the shape total length\n */\nconst getTotalLength = (pathInput: string | PathArray): number => {\n  return pathLengthFactory(pathInput).length;\n};\nexport default getTotalLength;\n","import getPathArea from './getPathArea';\nimport pathToCurve from '../convert/pathToCurve';\nimport type { PathArray } from '../types';\n\n/**\n * Check if a path is drawn clockwise and returns true if so,\n * false otherwise.\n *\n * @param path the path string or `pathArray`\n * @returns true when clockwise or false if not\n */\nconst getDrawDirection = (path: string | PathArray) => {\n  return getPathArea(pathToCurve(path)) >= 0;\n};\n\nexport default getDrawDirection;\n","import type { PathArray } from '../types';\nimport pathLengthFactory from './pathLengthFactory';\n\n/**\n * Returns [x,y] coordinates of a point at a given length of a shape.\n *\n * @param pathInput the `pathArray` to look into\n * @param distance the length of the shape to look at\n * @returns the requested {x, y} point coordinates\n */\nconst getPointAtLength = (pathInput: string | PathArray, distance: number): { x: number; y: number } => {\n  return pathLengthFactory(pathInput, distance).point;\n};\nexport default getPointAtLength;\n","import type { PathArray, PathSegment } from '../types';\nimport type { SegmentProperties } from '../interface';\nimport parsePathString from '../parser/parsePathString';\nimport getTotalLength from './getTotalLength';\n\n/**\n * Returns the segment, its index and length as well as\n * the length to that segment at a given length in a path.\n *\n * @param pathInput target `pathArray`\n * @param distance the given length\n * @returns the requested properties\n */\nconst getPropertiesAtLength = (pathInput: string | PathArray, distance?: number): SegmentProperties => {\n  const pathArray = parsePathString(pathInput);\n\n  let pathTemp = [...pathArray] as PathArray;\n  let pathLength = getTotalLength(pathTemp);\n  let index = pathTemp.length - 1;\n  let lengthAtSegment = 0;\n  let length = 0;\n  let segment = pathArray[0] as PathSegment;\n  const [x, y] = segment.slice(-2) as [number, number];\n  const point = { x, y };\n\n  // If the path is empty, return 0.\n  if (index <= 0 || !distance || !Number.isFinite(distance)) {\n    return {\n      segment,\n      index: 0,\n      length,\n      point,\n      lengthAtSegment,\n    };\n  }\n\n  if (distance >= pathLength) {\n    pathTemp = pathArray.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    return {\n      segment: pathArray[index],\n      index,\n      length,\n      lengthAtSegment,\n    };\n  }\n\n  const segments = [] as SegmentProperties[];\n  while (index > 0) {\n    segment = pathTemp[index];\n    pathTemp = pathTemp.slice(0, -1) as PathArray;\n    lengthAtSegment = getTotalLength(pathTemp);\n    length = pathLength - lengthAtSegment;\n    pathLength = lengthAtSegment;\n    segments.push({\n      segment,\n      index,\n      length,\n      lengthAtSegment,\n    });\n    index -= 1;\n  }\n\n  return segments.find(({ lengthAtSegment: l }) => l <= distance) as SegmentProperties;\n};\nexport default getPropertiesAtLength;\n","import type { PathArray } from '../types';\nimport type { PointProperties } from '../interface';\nimport getPointAtLength from './getPointAtLength';\nimport getPropertiesAtLength from './getPropertiesAtLength';\nimport getTotalLength from './getTotalLength';\nimport parsePathString from '../parser/parsePathString';\nimport normalizePath from '../process/normalizePath';\n\n/**\n * Returns the point and segment in path closest to a given point as well as\n * the distance to the path stroke.\n *\n * @see https://bl.ocks.org/mbostock/8027637\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the requested properties\n */\nconst getPropertiesAtPoint = (pathInput: string | PathArray, point: { x: number; y: number }): PointProperties => {\n  const path = parsePathString(pathInput);\n  const normalPath = normalizePath(path);\n  const pathLength = getTotalLength(path);\n  const distanceTo = (p: { x: number; y: number }) => {\n    const dx = p.x - point.x;\n    const dy = p.y - point.y;\n    return dx * dx + dy * dy;\n  };\n  let precision = 8;\n  let scan: { x: number; y: number };\n  let closest = { x: 0, y: 0 }; // make TS happy\n  let scanDistance = 0;\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    scan = getPointAtLength(normalPath, scanLength);\n    scanDistance = distanceTo(scan);\n    if (scanDistance < bestDistance) {\n      closest = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  let before: { x: number; y: number };\n  let after: { x: number; y: number };\n  let beforeLength = 0;\n  let afterLength = 0;\n  let beforeDistance = 0;\n  let afterDistance = 0;\n\n  while (precision > 0.5) {\n    beforeLength = bestLength - precision;\n    before = getPointAtLength(normalPath, beforeLength);\n    beforeDistance = distanceTo(before);\n    afterLength = bestLength + precision;\n    after = getPointAtLength(normalPath, afterLength);\n    afterDistance = distanceTo(after);\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      closest = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else if (afterLength <= pathLength && afterDistance < bestDistance) {\n      closest = after;\n      bestLength = afterLength;\n      bestDistance = afterDistance;\n    } else {\n      precision /= 2;\n    }\n  }\n\n  const segment = getPropertiesAtLength(path, bestLength);\n  const distance = Math.sqrt(bestDistance);\n\n  return { closest, distance, segment };\n};\n\nexport default getPropertiesAtPoint;\n","import type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\n\n/**\n * Returns the point in path closest to a given point.\n *\n * @param pathInput target `pathArray`\n * @param point the given point\n * @returns the best match\n */\nconst getClosestPoint = (pathInput: string | PathArray, point: { x: number; y: number }): { x: number; y: number } => {\n  return getPropertiesAtPoint(pathInput, point).closest;\n};\n\nexport default getClosestPoint;\n","import type { SegmentProperties } from '../interface';\nimport type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\n\n/**\n * Returns the path segment which contains a given point.\n *\n * @param path the `pathArray` to look into\n * @param point the point of the shape to look for\n * @returns the requested segment\n */\nconst getSegmentOfPoint = (\n  path: string | PathArray,\n  point: { x: number; y: number },\n): SegmentProperties | undefined => {\n  return getPropertiesAtPoint(path, point).segment;\n};\nexport default getSegmentOfPoint;\n","import type { PathArray, PathSegment } from '../types';\nimport getPropertiesAtLength from './getPropertiesAtLength';\n\n/**\n * Returns the segment at a given length.\n *\n * @param pathInput the target `pathArray`\n * @param distance the distance in path to look at\n * @returns the requested segment\n */\nconst getSegmentAtLength = (pathInput: string | PathArray, distance?: number): PathSegment | undefined => {\n  return getPropertiesAtLength(pathInput, distance).segment;\n};\n\nexport default getSegmentAtLength;\n","import type { PathArray } from '../types';\nimport getPropertiesAtPoint from './getPropertiesAtPoint';\n\n/**\n * Checks if a given point is in the stroke of a path.\n *\n * @param pathInput target path\n * @param point the given `{x,y}` point\n * @returns the query result\n */\nconst isPointInStroke = (pathInput: string | PathArray, point: { x: number; y: number }) => {\n  const { distance } = getPropertiesAtPoint(pathInput, point);\n  return Math.abs(distance) < 0.001; // 0.01 might be more permissive\n};\nexport default isPointInStroke;\n","import scanSegment from '../parser/scanSegment';\nimport skipSpaces from '../parser/skipSpaces';\nimport PathParser from '../parser/pathParser';\n\n/**\n * Parses a path string value to determine its validity\n * then returns true if it's valid or false otherwise.\n *\n * @param pathString the path string to be parsed\n * @returns the path string validity\n */\nconst isValidPath = (pathString: string) => {\n  if (typeof pathString !== 'string') {\n    return false;\n  }\n\n  const path = new PathParser(pathString);\n\n  skipSpaces(path);\n\n  while (path.index < path.max && !path.err.length) {\n    scanSegment(path);\n  }\n\n  return !path.err.length && 'mM'.includes(path.segments[0][0]);\n};\nexport default isValidPath;\n","import type { RelativeArray } from '../types';\nimport isPathArray from './isPathArray';\n\n/**\n * Iterates an array to check if it's a `pathArray`\n * with relative values.\n *\n * @param path the `pathArray` to be checked\n * @returns iteration result\n */\nconst isRelativeArray = (path: unknown): path is RelativeArray => {\n  return (\n    isPathArray(path) &&\n    // `isPathArray` checks if it's `Array`\n    path.slice(1).every(([pc]) => pc === pc.toLowerCase())\n  );\n};\nexport default isRelativeArray;\n","import type { PathArray } from 'src/types';\nimport defaultOptions from '../options/options';\n\n/**\n * Rounds the values of a `pathArray` instance to\n * a specified amount of decimals and returns it.\n *\n * @param path the source `pathArray`\n * @param roundOption the amount of decimals to round numbers to\n * @returns the resulted `pathArray` with rounded values\n */\nconst roundPath = (path: PathArray, roundOption?: number | 'off'): PathArray => {\n  let { round } = defaultOptions;\n  if (roundOption === 'off' || round === 'off') return [...path];\n  // allow for ZERO decimals\n  round = typeof roundOption === 'number' && roundOption >= 0 ? roundOption : round;\n  // to round values to the power\n  // the `round` value must be integer\n  const pow = typeof round === 'number' && round >= 1 ? 10 ** round : 1;\n\n  return path.map(pi => {\n    const values = pi\n      .slice(1)\n      .map(Number)\n      .map(n => (round ? Math.round(n * pow) / pow : Math.round(n)));\n    return [pi[0], ...values];\n  }) as PathArray;\n};\nexport default roundPath;\n","import type { PathArray } from '../types';\nimport roundPath from '../process/roundPath';\n\n/**\n * Returns a valid `d` attribute string value created\n * by rounding values and concatenating the `pathArray` segments.\n *\n * @param path the `pathArray` object\n * @param round amount of decimals to round values to\n * @returns the concatenated path string\n */\nconst pathToString = (path: PathArray, round?: number | 'off'): string => {\n  return roundPath(path, round)\n    .map(x => x[0] + x.slice(1).join(' '))\n    .join('');\n};\nexport default pathToString;\n","import type { CircleAttr, EllipseAttr, GlyphAttr, LineAttr, PolyAttr, RectAttr, ShapeParams } from '../interface';\nimport type { PathArray, PathSegment, ShapeOps, ShapeTypes } from '../types';\nimport pathToString from '../convert/pathToString';\nimport defaultOptions from '../options/options';\nimport error from '../parser/error';\nimport isValidPath from './isValidPath';\n\n/**\n * Supported shapes and their specific parameters.\n */\nconst shapeParams: ShapeParams = {\n  line: ['x1', 'y1', 'x2', 'y2'],\n  circle: ['cx', 'cy', 'r'],\n  ellipse: ['cx', 'cy', 'rx', 'ry'],\n  rect: ['width', 'height', 'x', 'y', 'rx', 'ry'],\n  polygon: ['points'],\n  polyline: ['points'],\n  glyph: ['d'],\n};\n\n/**\n * Returns a new `pathArray` from line attributes.\n *\n * @param attr shape configuration\n * @returns a new line `pathArray`\n */\nexport const getLinePath = (attr: LineAttr): PathArray => {\n  const { x1, y1, x2, y2 } = attr;\n  return [\n    ['M', x1, y1],\n    ['L', x2, y2],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from polyline/polygon attributes.\n *\n * @param attr shape configuration\n * @return a new polygon/polyline `pathArray`\n */\nexport const getPolyPath = (attr: PolyAttr): PathArray => {\n  const pathArray = [] as PathSegment[];\n  const points = (attr.points || '')\n    .trim()\n    .split(/[\\s|,]/)\n    .map(Number);\n\n  let index = 0;\n  while (index < points.length) {\n    pathArray.push([index ? 'L' : 'M', points[index], points[index + 1]]);\n    index += 2;\n  }\n\n  return (attr.type === 'polygon' ? [...pathArray, ['z']] : pathArray) as PathArray;\n};\n\n/**\n * Returns a new `pathArray` from circle attributes.\n *\n * @param attr shape configuration\n * @return a circle `pathArray`\n */\nexport const getCirclePath = (attr: CircleAttr): PathArray => {\n  const { cx, cy, r } = attr;\n\n  return [\n    ['M', cx - r, cy],\n    ['a', r, r, 0, 1, 0, 2 * r, 0],\n    ['a', r, r, 0, 1, 0, -2 * r, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` from ellipse attributes.\n *\n * @param attr shape configuration\n * @return an ellipse `pathArray`\n */\nexport const getEllipsePath = (attr: EllipseAttr): PathArray => {\n  const { cx, cy, rx, ry } = attr;\n\n  return [\n    ['M', cx - rx, cy],\n    ['a', rx, ry, 0, 1, 0, 2 * rx, 0],\n    ['a', rx, ry, 0, 1, 0, -2 * rx, 0],\n  ];\n};\n\n/**\n * Returns a new `pathArray` like from rect attributes.\n *\n * @param attr object with properties above\n * @return a new `pathArray` from `<rect>` attributes\n */\nexport const getRectanglePath = (attr: RectAttr): PathArray => {\n  const x = +attr.x || 0;\n  const y = +attr.y || 0;\n  const w = +attr.width;\n  const h = +attr.height;\n  let rx = +attr.rx;\n  let ry = +attr.ry;\n\n  // Validity checks from http://www.w3.org/TR/SVG/shapes.html#RectElement:\n  if (rx || ry) {\n    rx = !rx ? ry : rx;\n    ry = !ry ? rx : ry;\n\n    /* istanbul ignore else */\n    if (rx * 2 > w) rx -= (rx * 2 - w) / 2;\n    /* istanbul ignore else */\n    if (ry * 2 > h) ry -= (ry * 2 - h) / 2;\n\n    return [\n      ['M', x + rx, y],\n      ['h', w - rx * 2],\n      ['s', rx, 0, rx, ry],\n      ['v', h - ry * 2],\n      ['s', 0, ry, -rx, ry],\n      ['h', -w + rx * 2],\n      ['s', -rx, 0, -rx, -ry],\n      ['v', -h + ry * 2],\n      ['s', 0, -ry, rx, -ry],\n    ];\n  }\n\n  return [['M', x, y], ['h', w], ['v', h], ['H', x], ['Z']];\n};\n\n/**\n * Returns a new `<path>` element created from attributes of a `<line>`, `<polyline>`,\n * `<polygon>`, `<rect>`, `<ellipse>`, `<circle>` or `<glyph>`. If `replace` parameter\n * is `true`, it will replace the target. The default `ownerDocument` is your current\n * `document` browser page, if you want to use in server-side using `jsdom`, you can\n * pass the `jsdom` `document` to `ownDocument`.\n *\n * It can also work with an options object,\n *\n * @see ShapeOps\n *\n * The newly created `<path>` element keeps all non-specific\n * attributes like `class`, `fill`, etc.\n *\n * @param element target shape\n * @param replace option to replace target\n * @param ownerDocument document for create element\n * @return the newly created `<path>` element\n */\nconst shapeToPath = (\n  element: ShapeTypes | ShapeOps,\n  replace?: boolean,\n  ownerDocument?: Document,\n): SVGPathElement | false => {\n  const doc = ownerDocument || document;\n  const win = doc.defaultView || /* istanbul ignore next */ window;\n  const supportedShapes = Object.keys(shapeParams) as (keyof ShapeParams)[];\n  const elementIsElement = element instanceof win.SVGElement;\n  const tagName = elementIsElement ? element.tagName : null;\n\n  if (tagName && supportedShapes.every(s => tagName !== s)) {\n    throw TypeError(`${error}: \"${tagName}\" is not SVGElement`);\n  }\n\n  const path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n  const type = (elementIsElement ? tagName : element.type) as ShapeOps['type'];\n  const shapeAttrs = shapeParams[type] as string[];\n  const config = { type } as Record<string, string>;\n\n  if (elementIsElement) {\n    shapeAttrs.forEach(p => {\n      if (shapeAttrs.includes(p)) config[p] = element.getAttribute(p) as string;\n    });\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.values(element.attributes).forEach(({ name, value }) => {\n      if (!shapeAttrs.includes(name)) path.setAttribute(name, value);\n    });\n  } else {\n    Object.assign(config, element);\n    // set no-specific shape attributes: fill, stroke, etc\n    Object.keys(config).forEach(k => {\n      if (!shapeAttrs.includes(k) && k !== 'type') {\n        path.setAttribute(\n          k.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`),\n          config[k],\n        );\n      }\n    });\n  }\n\n  // set d\n  let description = '';\n  const round = defaultOptions.round as number;\n\n  /* istanbul ignore else */\n  if (type === 'circle') description = pathToString(getCirclePath(config as unknown as CircleAttr), round);\n  else if (type === 'ellipse') description = pathToString(getEllipsePath(config as unknown as EllipseAttr), round);\n  else if (['polyline', 'polygon'].includes(type))\n    description = pathToString(getPolyPath(config as unknown as PolyAttr), round);\n  else if (type === 'rect') description = pathToString(getRectanglePath(config as unknown as RectAttr), round);\n  else if (type === 'line') description = pathToString(getLinePath(config as unknown as LineAttr), round);\n  else if (type === 'glyph')\n    description = elementIsElement ? (element.getAttribute('d') as string) : (element as GlyphAttr).d;\n\n  // replace target element\n  if (isValidPath(description)) {\n    path.setAttribute('d', description);\n    if (replace && elementIsElement) {\n      element.before(path, element);\n      element.remove();\n    }\n    return path;\n  }\n  return false;\n};\nexport default shapeToPath;\n","import type { PathArray } from '../types';\n\n/**\n * Split a path into an `Array` of sub-path strings.\n *\n * In the process, values are converted to absolute\n * for visual consistency.\n *\n * @param pathInput the source `pathArray`\n * @return {SVGPath.pathArray[]} an array with all sub-path strings\n */\nconst splitPath = (pathInput: PathArray): PathArray[] => {\n  const composite = [] as PathArray[];\n  let path: PathArray;\n  let pi = -1;\n\n  pathInput.forEach(seg => {\n    if (seg[0] === 'M') {\n      path = [seg];\n      pi += 1;\n    } else {\n      path = [...path, seg];\n    }\n    composite[pi] = path;\n  });\n\n  return composite;\n};\nexport default splitPath;\n","import type {\n  aSegment,\n  hSegment,\n  PathArray,\n  RelativeArray,\n  RelativeCommand,\n  RelativeSegment,\n  vSegment,\n} from '../types';\nimport parsePathString from '../parser/parsePathString';\nimport isRelativeArray from '../util/isRelativeArray';\n\n/**\n * Parses a path string value or object and returns an array\n * of segments, all converted to relative values.\n *\n * @param pathInput the path string | object\n * @returns the resulted `pathArray` with relative values\n */\nconst pathToRelative = (pathInput: string | PathArray): RelativeArray => {\n  /* istanbul ignore else */\n  if (isRelativeArray(pathInput)) {\n    return [...pathInput];\n  }\n\n  const path = parsePathString(pathInput);\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  return path.map(segment => {\n    const values = segment.slice(1).map(Number);\n    const [pathCommand] = segment;\n    const relativeCommand = pathCommand.toLowerCase() as RelativeCommand;\n\n    if (pathCommand === 'M') {\n      [x, y] = values;\n      mx = x;\n      my = y;\n      return ['M', x, y];\n    }\n\n    let relativeSegment = [];\n\n    if (pathCommand !== relativeCommand) {\n      if (relativeCommand === 'a') {\n        relativeSegment = [\n          relativeCommand,\n          values[0],\n          values[1],\n          values[2],\n          values[3],\n          values[4],\n          values[5] - x,\n          values[6] - y,\n        ] as aSegment;\n      } else if (relativeCommand === 'v') {\n        relativeSegment = [relativeCommand, values[0] - y] as vSegment;\n      } else if (relativeCommand === 'h') {\n        relativeSegment = [relativeCommand, values[0] - x] as hSegment;\n      } else {\n        // use brakets for `eslint: no-case-declaration`\n        // https://stackoverflow.com/a/50753272/803358\n        const relValues = values.map((n, j) => n - (j % 2 ? y : x));\n        relativeSegment = [relativeCommand, ...relValues] as RelativeSegment;\n      }\n    } else {\n      if (pathCommand === 'm') {\n        mx = values[0] + x;\n        my = values[1] + y;\n      }\n      relativeSegment = [relativeCommand, ...values] as RelativeSegment;\n    }\n\n    const segLength = relativeSegment.length;\n    if (relativeCommand === 'z') {\n      x = mx;\n      y = my;\n    } else if (relativeCommand === 'h') {\n      x += relativeSegment[1] as number;\n    } else if (relativeCommand === 'v') {\n      y += relativeSegment[1] as number;\n    } else {\n      x += relativeSegment[segLength - 2] as number;\n      y += relativeSegment[segLength - 1] as number;\n    }\n\n    return relativeSegment as typeof segment;\n  }) as RelativeArray;\n};\nexport default pathToRelative;\n","import type { ParserParams } from 'src/interface';\nimport type {\n  AbsoluteSegment,\n  HSegment,\n  NormalSegment,\n  PathCommand,\n  ShortSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n  ZSegment,\n} from '../types';\n\n/**\n * Shorten a single segment of a `pathArray` object.\n *\n * @param segment the `absoluteSegment` object\n * @param normalSegment the `normalSegment` object\n * @param params the coordinates of the previous segment\n * @param prevCommand the path command of the previous segment\n * @returns the shortened segment\n */\nconst shortenSegment = (\n  segment: AbsoluteSegment,\n  normalSegment: NormalSegment,\n  params: ParserParams,\n  prevCommand: PathCommand,\n): ShortSegment => {\n  const [pathCommand] = segment;\n  const round4 = (n: number) => Math.round(n * 10 ** 4) / 10 ** 4;\n  const segmentValues = segment.slice(1).map(n => +n);\n  const normalValues = normalSegment.slice(1).map(n => +n);\n  const { x1: px1, y1: py1, x2: px2, y2: py2, x: px, y: py } = params;\n  let result = segment;\n  const [x, y] = normalValues.slice(-2);\n\n  if (!'TQ'.includes(pathCommand)) {\n    // optional but good to be cautious\n    params.qx = null;\n    params.qy = null;\n  }\n\n  if (['V', 'H', 'S', 'T', 'Z'].includes(pathCommand)) {\n    result = [pathCommand, ...segmentValues] as VSegment | HSegment | SSegment | TSegment | ZSegment;\n  } else if (pathCommand === 'L') {\n    if (round4(px) === round4(x)) {\n      result = ['V', y];\n    } else if (round4(py) === round4(y)) {\n      result = ['H', x];\n    }\n  } else if (pathCommand === 'C') {\n    const [x1, y1] = normalValues;\n\n    if (\n      'CS'.includes(prevCommand) &&\n      ((round4(x1) === round4(px1 * 2 - px2) && round4(y1) === round4(py1 * 2 - py2)) ||\n        (round4(px1) === round4(px2 * 2 - px) && round4(py1) === round4(py2 * 2 - py)))\n    ) {\n      result = ['S', ...normalValues.slice(-4)] as SSegment;\n    }\n    params.x1 = x1;\n    params.y1 = y1;\n  } else if (pathCommand === 'Q') {\n    const [qx, qy] = normalValues;\n    params.qx = qx;\n    params.qy = qy;\n\n    if (\n      'QT'.includes(prevCommand) &&\n      ((round4(qx) === round4(px1 * 2 - px2) && round4(qy) === round4(py1 * 2 - py2)) ||\n        (round4(px1) === round4(px2 * 2 - px) && round4(py1) === round4(py2 * 2 - py)))\n    ) {\n      result = ['T', ...normalValues.slice(-2)] as TSegment;\n    }\n  }\n\n  return result as ShortSegment;\n};\nexport default shortenSegment;\n","import roundPath from './roundPath';\nimport pathToAbsolute from '../convert/pathToAbsolute';\nimport pathToRelative from '../convert/pathToRelative';\nimport shortenSegment from './shortenSegment';\nimport paramsParser from '../parser/paramsParser';\nimport normalizePath from './normalizePath';\nimport type { PathSegment, HSegment, PathArray, VSegment, PathCommand, AbsoluteSegment } from '../types';\n\n/**\n * Optimizes a `pathArray` object:\n * * convert segments to shorthand if possible\n * * select shortest segments from absolute and relative `pathArray`s\n *\n * @param pathInput a string or `pathArray`\n * @param round the amount of decimals to round values to\n * @returns the optimized `pathArray`\n */\nconst optimizePath = (pathInput: PathArray, round: 'off' | number): PathArray => {\n  const path = pathToAbsolute(pathInput);\n  const normalPath = normalizePath(path);\n  const params = { ...paramsParser };\n  const allPathCommands = [] as PathCommand[];\n  const ii = path.length;\n  let pathCommand = '' as PathCommand;\n  let prevCommand = '' as PathCommand;\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n\n  for (let i = 0; i < ii; i += 1) {\n    [pathCommand] = path[i];\n\n    // Save current path command\n    allPathCommands[i] = pathCommand;\n    // Get previous path command for `shortenSegment`\n    if (i) prevCommand = allPathCommands[i - 1];\n    path[i] = shortenSegment(path[i], normalPath[i], params, prevCommand) as AbsoluteSegment;\n\n    const segment = path[i];\n    const seglen = segment.length;\n\n    // update C, S, Q, T specific params\n    params.x1 = +segment[seglen - 2];\n    params.y1 = +segment[seglen - 1];\n    params.x2 = +segment[seglen - 4] || params.x1;\n    params.y2 = +segment[seglen - 3] || params.y1;\n\n    // update x, y params\n    switch (pathCommand) {\n      case 'Z':\n        x = mx;\n        y = my;\n        break;\n      case 'H':\n        [, x] = segment as HSegment;\n        break;\n      case 'V':\n        [, y] = segment as VSegment;\n        break;\n      default:\n        [x, y] = segment.slice(-2).map(Number);\n\n        if (pathCommand === 'M') {\n          mx = x;\n          my = y;\n        }\n    }\n    params.x = x;\n    params.y = y;\n  }\n\n  const absolutePath = roundPath(path, round);\n  const relativePath = roundPath(pathToRelative(path), round);\n\n  return absolutePath.map((a: PathSegment, i: number) => {\n    if (i) {\n      return a.join('').length < relativePath[i].join('').length ? a : relativePath[i];\n    }\n    return a;\n  }) as PathArray;\n};\nexport default optimizePath;\n","import type { CurveArray } from '../types';\n\n/**\n * Reverses all segments of a `pathArray`\n * which consists of only C (cubic-bezier) path commands.\n *\n * @param path the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reverseCurve = (path: CurveArray): CurveArray => {\n  const rotatedCurve = path\n    .slice(1)\n    .map((x, i, curveOnly) =>\n      !i ? [...path[0].slice(1), ...x.slice(1)] : [...curveOnly[i - 1].slice(-2), ...x.slice(1)],\n    )\n    .map(x => x.map((_, i) => x[x.length - i - 2 * (1 - (i % 2))]))\n    .reverse();\n\n  return [['M', ...rotatedCurve[0].slice(0, 2)], ...rotatedCurve.map(x => ['C', ...x.slice(2)])] as CurveArray;\n};\nexport default reverseCurve;\n","import type {\n  ASegment,\n  CSegment,\n  HSegment,\n  MSegment,\n  PathArray,\n  PathSegment,\n  QSegment,\n  SSegment,\n  TSegment,\n  VSegment,\n} from 'src/types';\nimport pathToAbsolute from '../convert/pathToAbsolute';\nimport normalizePath from './normalizePath';\n\n/**\n * Reverses all segments of a `pathArray` and returns a new `pathArray` instance.\n *\n * @param pathInput the source `pathArray`\n * @returns the reversed `pathArray`\n */\nconst reversePath = (pathInput: PathArray): PathArray => {\n  const absolutePath = pathToAbsolute(pathInput);\n  const isClosed = absolutePath.slice(-1)[0][0] === 'Z';\n\n  const reversedPath = normalizePath(absolutePath)\n    .map((segment, i) => {\n      const [x, y] = segment.slice(-2).map(Number);\n      return {\n        seg: absolutePath[i], // absolute\n        n: segment, // normalized\n        c: absolutePath[i][0], // pathCommand\n        x, // x\n        y, // y\n      };\n    })\n    .map((seg, i, path) => {\n      const segment = seg.seg;\n      const data = seg.n;\n      const prevSeg = i && path[i - 1];\n      const nextSeg = path[i + 1];\n      const pathCommand = seg.c;\n      const pLen = path.length;\n      const x = i ? path[i - 1].x : path[pLen - 1].x;\n      const y = i ? path[i - 1].y : path[pLen - 1].y;\n      let result = [];\n\n      switch (pathCommand) {\n        case 'M':\n          result = (isClosed ? ['Z'] : [pathCommand, x, y]) as PathSegment;\n          break;\n        case 'A':\n          result = [pathCommand, ...segment.slice(1, -3), segment[5] === 1 ? 0 : 1, x, y] as ASegment;\n          break;\n        case 'C':\n          if (nextSeg && nextSeg.c === 'S') {\n            result = ['S', segment[1], segment[2], x, y] as SSegment;\n          } else {\n            result = [pathCommand, segment[3], segment[4], segment[1], segment[2], x, y] as CSegment;\n          }\n          break;\n        case 'S':\n          if (prevSeg && 'CS'.includes(prevSeg.c) && (!nextSeg || nextSeg.c !== 'S')) {\n            result = ['C', data[3], data[4], data[1], data[2], x, y] as CSegment;\n          } else {\n            result = [pathCommand, data[1], data[2], x, y] as SSegment;\n          }\n          break;\n        case 'Q':\n          if (nextSeg && nextSeg.c === 'T') {\n            result = ['T', x, y] as TSegment;\n          } else {\n            result = [pathCommand, ...segment.slice(1, -2), x, y] as QSegment;\n          }\n          break;\n        case 'T':\n          if (prevSeg && 'QT'.includes(prevSeg.c) && (!nextSeg || nextSeg.c !== 'T')) {\n            result = ['Q', data[1], data[2], x, y] as QSegment;\n          } else {\n            result = [pathCommand, x, y] as TSegment;\n          }\n          break;\n        case 'Z':\n          result = ['M', x, y] as MSegment;\n          break;\n        case 'H':\n          result = [pathCommand, x] as HSegment;\n          break;\n        case 'V':\n          result = [pathCommand, y] as VSegment;\n          break;\n        default:\n          result = [pathCommand, ...segment.slice(1, -2), x, y] as PathSegment;\n      }\n\n      return result;\n    });\n\n  return (isClosed ? reversedPath.reverse() : [reversedPath[0], ...reversedPath.slice(1).reverse()]) as PathArray;\n};\nexport default reversePath;\n","import CSSMatrix from '@thednp/dommatrix';\n// import type { TransformObject } from '../interface';\nimport type { TransformObjectValues } from '../types';\n\n/**\n * Returns a transformation matrix to apply to `<path>` elements.\n *\n * @see TransformObjectValues\n *\n * @param transform the `transformObject`\n * @returns a new transformation matrix\n */\nconst getSVGMatrix = (transform: TransformObjectValues): CSSMatrix => {\n  let matrix = new CSSMatrix();\n  const { origin } = transform;\n  const [originX, originY] = origin as [number, number, number];\n  const { translate } = transform;\n  const { rotate } = transform;\n  const { skew } = transform;\n  const { scale } = transform;\n\n  // set translate\n  if (\n    Array.isArray(translate) &&\n    translate.length >= 2 &&\n    translate.every(x => !Number.isNaN(+x)) &&\n    translate.some(x => x !== 0)\n  ) {\n    matrix = matrix.translate(...(translate as [number, number, number?]));\n  } else if (typeof translate === 'number' && !Number.isNaN(translate)) {\n    matrix = matrix.translate(translate);\n  }\n\n  if (rotate || skew || scale) {\n    // set SVG transform-origin, always defined\n    matrix = matrix.translate(originX, originY);\n\n    // set rotation\n    if (\n      Array.isArray(rotate) &&\n      rotate.length >= 2 &&\n      rotate.every(x => !Number.isNaN(+x)) &&\n      rotate.some(x => x !== 0)\n    ) {\n      matrix = matrix.rotate(...(rotate as [number, number, number?]));\n    } else if (typeof rotate === 'number' && !Number.isNaN(rotate)) {\n      matrix = matrix.rotate(rotate);\n    }\n\n    // set skew(s)\n    if (Array.isArray(skew) && skew.length === 2 && skew.every(x => !Number.isNaN(+x)) && skew.some(x => x !== 0)) {\n      matrix = skew[0] ? matrix.skewX(skew[0]) : matrix;\n      matrix = skew[1] ? matrix.skewY(skew[1]) : matrix;\n    } else if (typeof skew === 'number' && !Number.isNaN(skew)) {\n      matrix = matrix.skewX(skew);\n    }\n\n    // set scale\n    if (Array.isArray(scale) && scale.length >= 2 && scale.every(x => !Number.isNaN(+x)) && scale.some(x => x !== 1)) {\n      matrix = matrix.scale(...(scale as [number, number, number?]));\n    } else if (typeof scale === 'number' && !Number.isNaN(scale)) {\n      matrix = matrix.scale(scale);\n    }\n    // set SVG transform-origin\n    matrix = matrix.translate(-originX, -originY);\n  }\n\n  return matrix;\n};\nexport default getSVGMatrix;\n","import CSSMatrix from '@thednp/dommatrix';\n\n/**\n * Transforms a specified point using a matrix, returning a new\n * Tuple *Object* comprising of the transformed point.\n * Neither the matrix nor the original point are altered.\n *\n * @copyright thednp © 2021\n *\n * @param cssm CSSMatrix instance\n * @param v Tuple\n * @return the resulting Tuple\n */\nconst translatePoint = (cssm: CSSMatrix, v: [number, number, number, number]): [number, number, number, number] => {\n  let m = CSSMatrix.Translate(...(v.slice(0, -1) as [number, number, number]));\n\n  [, , , m.m44] = v;\n  m = cssm.multiply(m);\n\n  return [m.m41, m.m42, m.m43, m.m44];\n};\n\n/**\n * Returns the [x,y] projected coordinates for a given an [x,y] point\n * and an [x,y,z] perspective origin point.\n *\n * Equation found here =>\n * http://en.wikipedia.org/wiki/3D_projection#Diagram\n * Details =>\n * https://stackoverflow.com/questions/23792505/predicted-rendering-of-css-3d-transformed-pixel\n *\n * @param m the transformation matrix\n * @param point2D the initial [x,y] coordinates\n * @param origin the [x,y,z] transform origin\n * @returns the projected [x,y] coordinates\n */\nconst projection2d = (m: CSSMatrix, point2D: [number, number], origin: [number, number, number]): [number, number] => {\n  const [originX, originY, originZ] = origin;\n  const [x, y, z] = translatePoint(m, [...point2D, 0, 1]);\n\n  const relativePositionX = x - originX;\n  const relativePositionY = y - originY;\n  const relativePositionZ = z - originZ;\n\n  return [\n    // protect against division by ZERO\n    relativePositionX * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) + originX,\n    relativePositionY * (Math.abs(originZ) / Math.abs(relativePositionZ) || 1) + originY,\n  ];\n};\nexport default projection2d;\n","import normalizePath from './normalizePath';\nimport pathToAbsolute from '../convert/pathToAbsolute';\nimport segmentToCubic from './segmentToCubic';\nimport fixArc from './fixArc';\nimport getSVGMatrix from './getSVGMatrix';\nimport projection2d from './projection2d';\nimport paramsParser from '../parser/paramsParser';\nimport defaultOptions from '../options/options';\nimport type { PathArray, PathCommand, TransformObjectValues } from '../types';\nimport type { PathTransform, TransformObject } from '../interface';\n\n/**\n * Apply a 2D / 3D transformation to a `pathArray` instance.\n *\n * Since *SVGElement* doesn't support 3D transformation, this function\n * creates a 2D projection of the <path> element.\n *\n * @param path the `pathArray` to apply transformation\n * @param transform the transform functions `Object`\n * @returns the resulted `pathArray`\n */\nconst transformPath = (path: string | PathArray, transform?: Partial<TransformObject>): PathArray => {\n  let x = 0;\n  let y = 0;\n  let i;\n  let j;\n  let ii;\n  let jj;\n  let lx;\n  let ly;\n  const absolutePath = pathToAbsolute(path);\n  const transformProps = transform && Object.keys(transform);\n\n  // when used as a static method, invalidate somehow\n  if (!transform || (transformProps && !transformProps.length)) return [...absolutePath];\n\n  const normalizedPath = normalizePath(absolutePath);\n  // transform origin is extremely important\n  if (!transform.origin) {\n    const { origin: defaultOrigin } = defaultOptions;\n    Object.assign(transform, { origin: defaultOrigin });\n  }\n  const matrixInstance = getSVGMatrix(transform as TransformObjectValues);\n  const { origin } = transform;\n  const params = { ...paramsParser };\n  let segment = [];\n  let seglen = 0;\n  let pathCommand = '';\n  let transformedPath = [] as PathTransform[];\n  const allPathCommands = [] as PathCommand[]; // needed for arc to curve transformation\n\n  if (!matrixInstance.isIdentity) {\n    for (i = 0, ii = absolutePath.length; i < ii; i += 1) {\n      segment = absolutePath[i];\n\n      /* istanbul ignore else */\n      if (absolutePath[i]) [pathCommand] = segment;\n\n      // REPLACE Arc path commands with Cubic Beziers\n      // we don't have any scripting know-how on 3d ellipse transformation\n      // Arc segments don't work 3D transformations or skews\n      /// ////////////////////////////////////////\n      allPathCommands[i] = pathCommand as PathCommand;\n\n      if (pathCommand === 'A') {\n        segment = segmentToCubic(normalizedPath[i], params);\n\n        absolutePath[i] = segmentToCubic(normalizedPath[i], params);\n        fixArc(absolutePath, allPathCommands, i);\n\n        normalizedPath[i] = segmentToCubic(normalizedPath[i], params);\n        fixArc(normalizedPath, allPathCommands, i);\n        ii = Math.max(absolutePath.length, normalizedPath.length);\n      }\n\n      /// ////////////////////////////////////////\n      segment = normalizedPath[i];\n      seglen = segment.length;\n\n      params.x1 = +segment[seglen - 2];\n      params.y1 = +segment[seglen - 1];\n      params.x2 = +segment[seglen - 4] || params.x1;\n      params.y2 = +segment[seglen - 3] || params.y1;\n\n      const result = {\n        s: absolutePath[i],\n        c: absolutePath[i][0],\n        x: params.x1,\n        y: params.y1,\n      };\n\n      transformedPath = [...transformedPath, ...[result]];\n    }\n\n    return transformedPath.map(seg => {\n      pathCommand = seg.c;\n      segment = seg.s;\n      if (pathCommand === 'L' || pathCommand === 'H' || pathCommand === 'V') {\n        [lx, ly] = projection2d(matrixInstance, [seg.x, seg.y], origin as [number, number, number]);\n\n        /* istanbul ignore else */\n        if (x !== lx && y !== ly) {\n          segment = ['L', lx, ly];\n        } else if (y === ly) {\n          segment = ['H', lx];\n        } else if (x === lx) {\n          segment = ['V', ly];\n        }\n\n        // now update x and y\n        x = lx;\n        y = ly;\n\n        return segment;\n      } else {\n        for (j = 1, jj = segment.length; j < jj; j += 2) {\n          [x, y] = projection2d(matrixInstance, [+segment[j], +segment[j + 1]], origin as [number, number, number]);\n          segment[j] = x;\n          segment[j + 1] = y;\n        }\n\n        return segment;\n      }\n    }) as PathArray;\n  }\n  return [...absolutePath];\n};\nexport default transformPath;\n","import midPoint from '../math/midPoint';\nimport type { CubicSegment } from '../types';\n\n/**\n * Split a cubic-bezier segment into two.\n *\n * @param pts the cubic-bezier parameters\n * @return two new cubic-bezier segments\n */\nconst splitCubic = (pts: number[] /* , ratio */): [CubicSegment, CubicSegment] => {\n  const t = /* ratio || */ 0.5;\n  const p0 = pts.slice(0, 2) as [number, number];\n  const p1 = pts.slice(2, 4) as [number, number];\n  const p2 = pts.slice(4, 6) as [number, number];\n  const p3 = pts.slice(6, 8) as [number, number];\n  const p4 = midPoint(p0, p1, t);\n  const p5 = midPoint(p1, p2, t);\n  const p6 = midPoint(p2, p3, t);\n  const p7 = midPoint(p4, p5, t);\n  const p8 = midPoint(p5, p6, t);\n  const p9 = midPoint(p7, p8, t);\n\n  return [\n    ['C', ...p4, ...p7, ...p9],\n    ['C', ...p8, ...p6, ...p3],\n  ];\n};\nexport default splitCubic;\n","import { PathArray, TransformObjectValues } from './types';\nimport { Options, PathBBox, TransformEntries, TransformObject } from './interface';\nimport defaultOptions from './options/options';\n\nimport error from './parser/error';\nimport parsePathString from './parser/parsePathString';\n\nimport polygonArea from './math/polygonArea';\nimport polygonLength from './math/polygonLength';\n\nimport CSSMatrix from '@thednp/dommatrix';\nimport getPathBBox from './util/getPathBBox';\nimport getPathArea from './util/getPathArea';\nimport getTotalLength from './util/getTotalLength';\nimport getDrawDirection from './util/getDrawDirection';\nimport getPointAtLength from './util/getPointAtLength';\nimport pathLengthFactory from './util/pathLengthFactory';\n\nimport getPropertiesAtLength from './util/getPropertiesAtLength';\nimport getPropertiesAtPoint from './util/getPropertiesAtPoint';\nimport getClosestPoint from './util/getClosestPoint';\nimport getSegmentOfPoint from './util/getSegmentOfPoint';\nimport getSegmentAtLength from './util/getSegmentAtLength';\nimport isPointInStroke from './util/isPointInStroke';\n\nimport isValidPath from './util/isValidPath';\nimport isPathArray from './util/isPathArray';\nimport isAbsoluteArray from './util/isAbsoluteArray';\nimport isRelativeArray from './util/isRelativeArray';\nimport isCurveArray from './util/isCurveArray';\nimport isNormalizedArray from './util/isNormalizedArray';\nimport shapeToPath from './util/shapeToPath';\n\nimport roundPath from './process/roundPath';\nimport splitPath from './process/splitPath';\nimport optimizePath from './process/optimizePath';\nimport reverseCurve from './process/reverseCurve';\nimport reversePath from './process/reversePath';\nimport normalizePath from './process/normalizePath';\nimport transformPath from './process/transformPath';\nimport splitCubic from './process/splitCubic';\n\nimport pathToAbsolute from './convert/pathToAbsolute';\nimport pathToRelative from './convert/pathToRelative';\nimport pathToCurve from './convert/pathToCurve';\nimport pathToString from './convert/pathToString';\n\n/**\n * Creates a new SVGPathCommander instance with the following properties:\n * * segments: `pathArray`\n * * round: number\n * * origin: [number, number, number?]\n *\n * @class\n * @author thednp <https://github.com/thednp/svg-path-commander>\n * @returns {SVGPathCommander} a new SVGPathCommander instance\n */\nclass SVGPathCommander {\n  // bring main utilities to front\n  public static CSSMatrix = CSSMatrix;\n  public static getPathBBox = getPathBBox;\n  public static getPathArea = getPathArea;\n  public static getTotalLength = getTotalLength;\n  public static getDrawDirection = getDrawDirection;\n  public static getPointAtLength = getPointAtLength;\n  public static pathLengthFactory = pathLengthFactory;\n  public static getPropertiesAtLength = getPropertiesAtLength;\n  public static getPropertiesAtPoint = getPropertiesAtPoint;\n  public static polygonLength = polygonLength;\n  public static polygonArea = polygonArea;\n  public static getClosestPoint = getClosestPoint;\n  public static getSegmentOfPoint = getSegmentOfPoint;\n  public static getSegmentAtLength = getSegmentAtLength;\n  public static isPointInStroke = isPointInStroke;\n  public static isValidPath = isValidPath;\n  public static isPathArray = isPathArray;\n  public static isAbsoluteArray = isAbsoluteArray;\n  public static isRelativeArray = isRelativeArray;\n  public static isCurveArray = isCurveArray;\n  public static isNormalizedArray = isNormalizedArray;\n  public static shapeToPath = shapeToPath;\n  public static parsePathString = parsePathString;\n  public static roundPath = roundPath;\n  public static splitPath = splitPath;\n  public static splitCubic = splitCubic;\n  public static optimizePath = optimizePath;\n  public static reverseCurve = reverseCurve;\n  public static reversePath = reversePath;\n  public static normalizePath = normalizePath;\n  public static transformPath = transformPath;\n  public static pathToAbsolute = pathToAbsolute;\n  public static pathToRelative = pathToRelative;\n  public static pathToCurve = pathToCurve;\n  public static pathToString = pathToString;\n  // declare class properties\n  declare segments: PathArray;\n  declare round: number | 'off';\n  declare origin: [number, number, number];\n\n  /**\n   * @constructor\n   * @param {string} pathValue the path string\n   * @param {any} config instance options\n   */\n  constructor(pathValue: string, config?: Partial<Options>) {\n    const instanceOptions = config || {};\n    const undefPath = typeof pathValue === 'undefined';\n\n    if (undefPath || !pathValue.length) {\n      throw TypeError(`${error}: \"pathValue\" is ${undefPath ? 'undefined' : 'empty'}`);\n    }\n\n    const segments = parsePathString(pathValue);\n    // if (typeof segments === 'string') {\n    //   throw TypeError(segments);\n    // }\n\n    this.segments = segments;\n\n    const { width, height, cx, cy, cz } = this.getBBox();\n\n    // set instance options.round\n    const { round: roundOption, origin: originOption } = instanceOptions;\n    let round: number | 'off';\n\n    if (roundOption === 'auto') {\n      const pathScale = `${Math.floor(Math.max(width, height))}`.length;\n      round = pathScale >= 4 ? 0 : 4 - pathScale;\n    } else if (Number.isInteger(roundOption) || roundOption === 'off') {\n      round = roundOption as number | 'off';\n    } else {\n      round = defaultOptions.round as number;\n    }\n\n    // set instance options.origin\n    // the SVGPathCommander class will always override the default origin\n    let origin: [number, number, number];\n    if (Array.isArray(originOption) && originOption.length >= 2) {\n      const [originX, originY, originZ] = originOption.map(Number);\n      origin = [\n        !Number.isNaN(originX) ? originX : cx,\n        !Number.isNaN(originY) ? originY : cy,\n        !Number.isNaN(originZ) ? originZ : cz,\n      ];\n    } else {\n      origin = [cx, cy, cz];\n    }\n\n    this.round = round;\n    this.origin = origin;\n\n    return this;\n  }\n\n  /**\n   * Returns the path bounding box, equivalent to native `path.getBBox()`.\n   *\n   * @public\n   * @returns the pathBBox\n   */\n  getBBox(): PathBBox {\n    return getPathBBox(this.segments);\n  }\n\n  /**\n   * Returns the total path length, equivalent to native `path.getTotalLength()`.\n   *\n   * @public\n   * @returns the path total length\n   */\n  getTotalLength() {\n    return getTotalLength(this.segments);\n  }\n\n  /**\n   * Returns an `{x,y}` point in the path stroke at a given length,\n   * equivalent to the native `path.getPointAtLength()`.\n   *\n   * @public\n   * @param length the length\n   * @returns the requested point\n   */\n  getPointAtLength(length: number): { x: number; y: number } {\n    return getPointAtLength(this.segments, length);\n  }\n\n  /**\n   * Convert path to absolute values\n   *\n   * @public\n   */\n  toAbsolute() {\n    const { segments } = this;\n    this.segments = pathToAbsolute(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to relative values\n   *\n   * @public\n   */\n  toRelative() {\n    const { segments } = this;\n    this.segments = pathToRelative(segments);\n    return this;\n  }\n\n  /**\n   * Convert path to cubic-bezier values. In addition, un-necessary `Z`\n   * segment is removed if previous segment extends to the `M` segment.\n   *\n   * @public\n   */\n  toCurve() {\n    const { segments } = this;\n    this.segments = pathToCurve(segments);\n    return this;\n  }\n\n  /**\n   * Reverse the order of the segments and their values.\n   *\n   * @param onlySubpath option to reverse all sub-paths except first\n   * @public\n   */\n  reverse(onlySubpath?: boolean) {\n    this.toAbsolute();\n\n    const { segments } = this;\n    const split = splitPath(segments);\n    const subPath = split.length > 1 ? split : false;\n\n    const absoluteMultiPath = subPath\n      ? [...subPath].map((x, i) => {\n          if (onlySubpath) {\n            // return i ? reversePath(x) : parsePathString(x);\n            return i ? reversePath(x) : [...x];\n          }\n          return reversePath(x);\n        })\n      : [...segments];\n\n    let path = [];\n    if (subPath) {\n      path = absoluteMultiPath.flat(1);\n    } else {\n      path = onlySubpath ? segments : reversePath(segments);\n    }\n\n    this.segments = [...path] as PathArray;\n    return this;\n  }\n\n  /**\n   * Normalize path in 2 steps:\n   * * convert `pathArray`(s) to absolute values\n   * * convert shorthand notation to standard notation\n   *\n   * @public\n   */\n  normalize() {\n    const { segments } = this;\n    this.segments = normalizePath(segments);\n    return this;\n  }\n\n  /**\n   * Optimize `pathArray` values:\n   * * convert segments to absolute and/or relative values\n   * * select segments with shortest resulted string\n   * * round values to the specified `decimals` option value\n   *\n   * @public\n   */\n  optimize() {\n    const { segments } = this;\n\n    this.segments = optimizePath(segments, this.round);\n    return this;\n  }\n\n  /**\n   * Transform path using values from an `Object` defined as `transformObject`.\n   *\n   * @see TransformObject for a quick refference\n   *\n   * @param source a `transformObject`as described above\n   * @public\n   */\n  transform(source?: Partial<TransformObject>) {\n    if (\n      !source ||\n      typeof source !== 'object' ||\n      (typeof source === 'object' && !['translate', 'rotate', 'skew', 'scale'].some(x => x in source))\n    )\n      return this;\n\n    const {\n      segments,\n      origin: [cx, cy, cz],\n    } = this;\n    const transform = {} as TransformObjectValues;\n    for (const [k, v] of Object.entries(source) as TransformEntries) {\n      if (k === 'skew' && Array.isArray(v)) {\n        transform[k] = v.map(Number) as [number, number];\n      } else if ((k === 'rotate' || k === 'translate' || k === 'origin' || k === 'scale') && Array.isArray(v)) {\n        transform[k] = v.map(Number) as [number, number, number];\n      } else if (k !== 'origin' && typeof Number(v) === 'number') transform[k] = Number(v);\n    }\n\n    // if origin is not specified\n    // it's important that we have one\n    const { origin } = transform;\n\n    if (Array.isArray(origin) && origin.length >= 2) {\n      const [originX, originY, originZ] = origin.map(Number);\n      transform.origin = [!Number.isNaN(originX) ? originX : cx, !Number.isNaN(originY) ? originY : cy, originZ || cz];\n    } else {\n      transform.origin = [cx, cy, cz];\n    }\n\n    this.segments = transformPath(segments, transform);\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg vertically\n   *\n   * @public\n   */\n  flipX() {\n    this.transform({ rotate: [0, 180, 0] });\n    return this;\n  }\n\n  /**\n   * Rotate path 180deg horizontally\n   *\n   * @public\n   */\n  flipY() {\n    this.transform({ rotate: [180, 0, 0] });\n    return this;\n  }\n\n  /**\n   * Export the current path to be used\n   * for the `d` (description) attribute.\n   *\n   * @public\n   * @return the path string\n   */\n  toString() {\n    return pathToString(this.segments, this.round);\n  }\n}\n\nexport default SVGPathCommander;\n"],"names":["defaultOptions","error","paramsCount","finalizeSegment","path","pathCommand","LK","data","scanFlag","index","pathValue","code","isDigit","invalidPathValue","scanParam","max","start","zeroFirst","hasCeiling","hasDecimal","hasDot","ch","isSpace","skipSpaces","isPathCommand","isDigitStart","isArcCommand","scanSegment","cmdCode","reqParams","paramCounts","i","PathParser","pathString","isPathArray","seg","lk","parsePathString","pathInput","polygonArea","polygon","n","a","b","area","distanceSquareRoot","polygonLength","length","point","Z","z","s","e","p","$","E","P","y","g","r","m","h","c","u","f","w","o","d","A","M","X","O","x","Y","F","T","k","I","v","R","D","N","dommatrix","isAbsoluteArray","pathToAbsolute","mx","my","segment","values","absCommand","absoluteSegment","absValues","j","normalizeSegment","params","px1","py1","px2","py2","result","x1","y1","qx","qy","nqx","nqy","isNormalizedArray","pc","paramsParser","normalizePath","ii","seglen","midPoint","t","ax","ay","bx","by","segmentLineFactory","x2","y2","distance","angleBetween","v0","v1","v0x","v0y","v1x","v1y","getPointAtArcSegmentLength","RX","RY","angle","LAF","SF","abs","sin","cos","sqrt","PI","rx","ry","xRotRad","dx","dy","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","startAngle","endVector","sweepAngle","alpha","ellipseComponentX","ellipseComponentY","segmentArcFactory","X1","Y1","X2","Y2","distanceIsNumber","LENGTH","prev","cur","POINT","POINTS","sampleSize","dv","getPointAtCubicSegmentLength","c1x","c1y","c2x","c2y","t1","segmentCubicFactory","getPointAtQuadSegmentLength","cx","cy","segmentQuadFactory","pathLengthFactory","isM","MIN","MAX","min","ll","getPathBBox","xMin","yMin","xMax","yMax","width","height","fixArc","allPathCommands","ni","isCurveArray","rotateVector","rad","arcToCubic","recursive","d120","res","xy","f1","f2","rx2","ry2","df","f2old","x2old","y2old","c1","s1","c2","s2","hx","hy","m1","m2","m3","m4","newres","quadToCubic","r13","r23","lineToCubic","segmentToCubic","args","px","py","pathToCurve","getCubicSegArea","getPathArea","len","getTotalLength","getDrawDirection","getPointAtLength","getPropertiesAtLength","pathArray","pathTemp","pathLength","lengthAtSegment","segments","l","getPropertiesAtPoint","normalPath","distanceTo","precision","scan","closest","scanDistance","bestLength","bestDistance","scanLength","before","after","beforeLength","afterLength","beforeDistance","afterDistance","getClosestPoint","getSegmentOfPoint","getSegmentAtLength","isPointInStroke","isValidPath","isRelativeArray","roundPath","roundOption","round","pow","pi","pathToString","shapeParams","getLinePath","attr","getPolyPath","points","getCirclePath","getEllipsePath","getRectanglePath","shapeToPath","element","replace","ownerDocument","doc","win","supportedShapes","elementIsElement","tagName","type","shapeAttrs","config","name","value","description","splitPath","composite","pathToRelative","relativeCommand","relativeSegment","relValues","segLength","shortenSegment","normalSegment","prevCommand","round4","segmentValues","normalValues","optimizePath","absolutePath","relativePath","reverseCurve","rotatedCurve","curveOnly","_","reversePath","isClosed","reversedPath","prevSeg","nextSeg","pLen","getSVGMatrix","transform","matrix","CSSMatrix","origin","originX","originY","translate","rotate","skew","scale","translatePoint","cssm","projection2d","point2D","originZ","relativePositionX","relativePositionY","relativePositionZ","transformPath","jj","lx","ly","transformProps","normalizedPath","defaultOrigin","matrixInstance","transformedPath","splitCubic","pts","p0","p1","p2","p3","p4","p5","p6","p7","p8","p9","SVGPathCommander","instanceOptions","undefPath","cz","originOption","pathScale","onlySubpath","split","subPath","absoluteMultiPath","source"],"mappings":"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"}